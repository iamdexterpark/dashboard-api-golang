// Code generated by go-swagger; DO NOT EDIT.

package appliance

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UpdateNetworkApplianceSecurityMalwareReader is a Reader for the UpdateNetworkApplianceSecurityMalware structure.
type UpdateNetworkApplianceSecurityMalwareReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *UpdateNetworkApplianceSecurityMalwareReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewUpdateNetworkApplianceSecurityMalwareOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewUpdateNetworkApplianceSecurityMalwareOK creates a UpdateNetworkApplianceSecurityMalwareOK with default headers values
func NewUpdateNetworkApplianceSecurityMalwareOK() *UpdateNetworkApplianceSecurityMalwareOK {
	return &UpdateNetworkApplianceSecurityMalwareOK{}
}

/* UpdateNetworkApplianceSecurityMalwareOK describes a response with status code 200, with default header values.

Successful operation
*/
type UpdateNetworkApplianceSecurityMalwareOK struct {
	Payload interface{}
}

func (o *UpdateNetworkApplianceSecurityMalwareOK) Error() string {
	return fmt.Sprintf("[PUT /networks/{networkId}/appliance/security/malware][%d] updateNetworkApplianceSecurityMalwareOK  %+v", 200, o.Payload)
}
func (o *UpdateNetworkApplianceSecurityMalwareOK) GetPayload() interface{} {
	return o.Payload
}

func (o *UpdateNetworkApplianceSecurityMalwareOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response payload
	if err := consumer.Consume(response.Body(), &o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*UpdateNetworkApplianceSecurityMalwareBody update network appliance security malware body
// Example: {"allowedFiles":[{"comment":"allow ZIP file","sha256":"e82c5f7d75004727e1f3b94426b9a11c8bc4c312a9170ac9a73abace40aef503"}],"allowedUrls":[{"comment":"allow example.org","url":"example.org"},{"comment":"allow help.com.au","url":"help.com.au"}],"mode":"enabled"}
swagger:model UpdateNetworkApplianceSecurityMalwareBody
*/
type UpdateNetworkApplianceSecurityMalwareBody struct {

	// The sha256 digests of files that should be permitted by the malware detection engine. If omitted, the current config will remain unchanged. This is available only if your network supports AMP allow listing
	AllowedFiles []*UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedFilesItems0 `json:"allowedFiles"`

	// The urls that should be permitted by the malware detection engine. If omitted, the current config will remain unchanged. This is available only if your network supports AMP allow listing
	AllowedUrls []*UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedUrlsItems0 `json:"allowedUrls"`

	// Set mode to 'enabled' to enable malware prevention, otherwise 'disabled'
	// Required: true
	// Enum: [enabled disabled]
	Mode *string `json:"mode"`
}

// Validate validates this update network appliance security malware body
func (o *UpdateNetworkApplianceSecurityMalwareBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAllowedFiles(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAllowedUrls(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkApplianceSecurityMalwareBody) validateAllowedFiles(formats strfmt.Registry) error {
	if swag.IsZero(o.AllowedFiles) { // not required
		return nil
	}

	for i := 0; i < len(o.AllowedFiles); i++ {
		if swag.IsZero(o.AllowedFiles[i]) { // not required
			continue
		}

		if o.AllowedFiles[i] != nil {
			if err := o.AllowedFiles[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("updateNetworkApplianceSecurityMalware" + "." + "allowedFiles" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("updateNetworkApplianceSecurityMalware" + "." + "allowedFiles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *UpdateNetworkApplianceSecurityMalwareBody) validateAllowedUrls(formats strfmt.Registry) error {
	if swag.IsZero(o.AllowedUrls) { // not required
		return nil
	}

	for i := 0; i < len(o.AllowedUrls); i++ {
		if swag.IsZero(o.AllowedUrls[i]) { // not required
			continue
		}

		if o.AllowedUrls[i] != nil {
			if err := o.AllowedUrls[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("updateNetworkApplianceSecurityMalware" + "." + "allowedUrls" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("updateNetworkApplianceSecurityMalware" + "." + "allowedUrls" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var updateNetworkApplianceSecurityMalwareBodyTypeModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["enabled","disabled"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updateNetworkApplianceSecurityMalwareBodyTypeModePropEnum = append(updateNetworkApplianceSecurityMalwareBodyTypeModePropEnum, v)
	}
}

const (

	// UpdateNetworkApplianceSecurityMalwareBodyModeEnabled captures enum value "enabled"
	UpdateNetworkApplianceSecurityMalwareBodyModeEnabled string = "enabled"

	// UpdateNetworkApplianceSecurityMalwareBodyModeDisabled captures enum value "disabled"
	UpdateNetworkApplianceSecurityMalwareBodyModeDisabled string = "disabled"
)

// prop value enum
func (o *UpdateNetworkApplianceSecurityMalwareBody) validateModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, updateNetworkApplianceSecurityMalwareBodyTypeModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *UpdateNetworkApplianceSecurityMalwareBody) validateMode(formats strfmt.Registry) error {

	if err := validate.Required("updateNetworkApplianceSecurityMalware"+"."+"mode", "body", o.Mode); err != nil {
		return err
	}

	// value enum
	if err := o.validateModeEnum("updateNetworkApplianceSecurityMalware"+"."+"mode", "body", *o.Mode); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this update network appliance security malware body based on the context it is used
func (o *UpdateNetworkApplianceSecurityMalwareBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAllowedFiles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateAllowedUrls(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkApplianceSecurityMalwareBody) contextValidateAllowedFiles(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.AllowedFiles); i++ {

		if o.AllowedFiles[i] != nil {
			if err := o.AllowedFiles[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("updateNetworkApplianceSecurityMalware" + "." + "allowedFiles" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("updateNetworkApplianceSecurityMalware" + "." + "allowedFiles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *UpdateNetworkApplianceSecurityMalwareBody) contextValidateAllowedUrls(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.AllowedUrls); i++ {

		if o.AllowedUrls[i] != nil {
			if err := o.AllowedUrls[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("updateNetworkApplianceSecurityMalware" + "." + "allowedUrls" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("updateNetworkApplianceSecurityMalware" + "." + "allowedUrls" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkApplianceSecurityMalwareBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkApplianceSecurityMalwareBody) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkApplianceSecurityMalwareBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedFilesItems0 update network appliance security malware params body allowed files items0
swagger:model UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedFilesItems0
*/
type UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedFilesItems0 struct {

	// Comment about the allowed entity
	// Required: true
	Comment *string `json:"comment"`

	// The file sha256 hash to allow
	// Required: true
	Sha256 *string `json:"sha256"`
}

// Validate validates this update network appliance security malware params body allowed files items0
func (o *UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedFilesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSha256(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedFilesItems0) validateComment(formats strfmt.Registry) error {

	if err := validate.Required("comment", "body", o.Comment); err != nil {
		return err
	}

	return nil
}

func (o *UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedFilesItems0) validateSha256(formats strfmt.Registry) error {

	if err := validate.Required("sha256", "body", o.Sha256); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this update network appliance security malware params body allowed files items0 based on context it is used
func (o *UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedFilesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedFilesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedFilesItems0) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedFilesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedUrlsItems0 update network appliance security malware params body allowed urls items0
swagger:model UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedUrlsItems0
*/
type UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedUrlsItems0 struct {

	// Comment about the allowed entity
	// Required: true
	Comment *string `json:"comment"`

	// The url to allow
	// Required: true
	URL *string `json:"url"`
}

// Validate validates this update network appliance security malware params body allowed urls items0
func (o *UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedUrlsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateURL(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedUrlsItems0) validateComment(formats strfmt.Registry) error {

	if err := validate.Required("comment", "body", o.Comment); err != nil {
		return err
	}

	return nil
}

func (o *UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedUrlsItems0) validateURL(formats strfmt.Registry) error {

	if err := validate.Required("url", "body", o.URL); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this update network appliance security malware params body allowed urls items0 based on context it is used
func (o *UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedUrlsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedUrlsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedUrlsItems0) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkApplianceSecurityMalwareParamsBodyAllowedUrlsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

// Code generated by go-swagger; DO NOT EDIT.

package organizations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ClaimIntoOrganizationReader is a Reader for the ClaimIntoOrganization structure.
type ClaimIntoOrganizationReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *ClaimIntoOrganizationReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewClaimIntoOrganizationOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewClaimIntoOrganizationOK creates a ClaimIntoOrganizationOK with default headers values
func NewClaimIntoOrganizationOK() *ClaimIntoOrganizationOK {
	return &ClaimIntoOrganizationOK{}
}

/* ClaimIntoOrganizationOK describes a response with status code 200, with default header values.

Successful operation
*/
type ClaimIntoOrganizationOK struct {
	Payload interface{}
}

func (o *ClaimIntoOrganizationOK) Error() string {
	return fmt.Sprintf("[POST /organizations/{organizationId}/claim][%d] claimIntoOrganizationOK  %+v", 200, o.Payload)
}
func (o *ClaimIntoOrganizationOK) GetPayload() interface{} {
	return o.Payload
}

func (o *ClaimIntoOrganizationOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response payload
	if err := consumer.Consume(response.Body(), &o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*ClaimIntoOrganizationBody claim into organization body
// Example: {"licenses":[{"key":"Z2XXXXXXXXXX","mode":"addDevices"}],"orders":["4CXXXXXXX"],"serials":["Q234-ABCD-5678"]}
swagger:model ClaimIntoOrganizationBody
*/
type ClaimIntoOrganizationBody struct {

	// The licenses that should be claimed
	Licenses []*ClaimIntoOrganizationParamsBodyLicensesItems0 `json:"licenses"`

	// The numbers of the orders that should be claimed
	Orders []string `json:"orders"`

	// The serials of the devices that should be claimed
	Serials []string `json:"serials"`
}

// Validate validates this claim into organization body
func (o *ClaimIntoOrganizationBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLicenses(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ClaimIntoOrganizationBody) validateLicenses(formats strfmt.Registry) error {
	if swag.IsZero(o.Licenses) { // not required
		return nil
	}

	for i := 0; i < len(o.Licenses); i++ {
		if swag.IsZero(o.Licenses[i]) { // not required
			continue
		}

		if o.Licenses[i] != nil {
			if err := o.Licenses[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("claimIntoOrganization" + "." + "licenses" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("claimIntoOrganization" + "." + "licenses" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this claim into organization body based on the context it is used
func (o *ClaimIntoOrganizationBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLicenses(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ClaimIntoOrganizationBody) contextValidateLicenses(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Licenses); i++ {

		if o.Licenses[i] != nil {
			if err := o.Licenses[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("claimIntoOrganization" + "." + "licenses" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("claimIntoOrganization" + "." + "licenses" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *ClaimIntoOrganizationBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ClaimIntoOrganizationBody) UnmarshalBinary(b []byte) error {
	var res ClaimIntoOrganizationBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ClaimIntoOrganizationParamsBodyLicensesItems0 claim into organization params body licenses items0
swagger:model ClaimIntoOrganizationParamsBodyLicensesItems0
*/
type ClaimIntoOrganizationParamsBodyLicensesItems0 struct {

	// The key of the license
	// Required: true
	Key *string `json:"key"`

	// Either 'renew' or 'addDevices'. 'addDevices' will increase the license limit, while 'renew' will extend the amount of time until expiration. Defaults to 'addDevices'. All licenses must be claimed with the same mode, and at most one renewal can be claimed at a time. This parameter is legacy and does not apply to organizations with per-device licensing enabled.
	// Enum: [addDevices renew]
	Mode string `json:"mode,omitempty"`
}

// Validate validates this claim into organization params body licenses items0
func (o *ClaimIntoOrganizationParamsBodyLicensesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateKey(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ClaimIntoOrganizationParamsBodyLicensesItems0) validateKey(formats strfmt.Registry) error {

	if err := validate.Required("key", "body", o.Key); err != nil {
		return err
	}

	return nil
}

var claimIntoOrganizationParamsBodyLicensesItems0TypeModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["addDevices","renew"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		claimIntoOrganizationParamsBodyLicensesItems0TypeModePropEnum = append(claimIntoOrganizationParamsBodyLicensesItems0TypeModePropEnum, v)
	}
}

const (

	// ClaimIntoOrganizationParamsBodyLicensesItems0ModeAddDevices captures enum value "addDevices"
	ClaimIntoOrganizationParamsBodyLicensesItems0ModeAddDevices string = "addDevices"

	// ClaimIntoOrganizationParamsBodyLicensesItems0ModeRenew captures enum value "renew"
	ClaimIntoOrganizationParamsBodyLicensesItems0ModeRenew string = "renew"
)

// prop value enum
func (o *ClaimIntoOrganizationParamsBodyLicensesItems0) validateModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, claimIntoOrganizationParamsBodyLicensesItems0TypeModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *ClaimIntoOrganizationParamsBodyLicensesItems0) validateMode(formats strfmt.Registry) error {
	if swag.IsZero(o.Mode) { // not required
		return nil
	}

	// value enum
	if err := o.validateModeEnum("mode", "body", o.Mode); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this claim into organization params body licenses items0 based on context it is used
func (o *ClaimIntoOrganizationParamsBodyLicensesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ClaimIntoOrganizationParamsBodyLicensesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ClaimIntoOrganizationParamsBodyLicensesItems0) UnmarshalBinary(b []byte) error {
	var res ClaimIntoOrganizationParamsBodyLicensesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

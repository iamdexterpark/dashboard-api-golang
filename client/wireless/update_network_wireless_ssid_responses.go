// Code generated by go-swagger; DO NOT EDIT.

package wireless

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UpdateNetworkWirelessSsidReader is a Reader for the UpdateNetworkWirelessSsid structure.
type UpdateNetworkWirelessSsidReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *UpdateNetworkWirelessSsidReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewUpdateNetworkWirelessSsidOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewUpdateNetworkWirelessSsidOK creates a UpdateNetworkWirelessSsidOK with default headers values
func NewUpdateNetworkWirelessSsidOK() *UpdateNetworkWirelessSsidOK {
	return &UpdateNetworkWirelessSsidOK{}
}

/* UpdateNetworkWirelessSsidOK describes a response with status code 200, with default header values.

Successful operation
*/
type UpdateNetworkWirelessSsidOK struct {
	Payload interface{}
}

func (o *UpdateNetworkWirelessSsidOK) Error() string {
	return fmt.Sprintf("[PUT /networks/{networkId}/wireless/ssids/{number}][%d] updateNetworkWirelessSsidOK  %+v", 200, o.Payload)
}
func (o *UpdateNetworkWirelessSsidOK) GetPayload() interface{} {
	return o.Payload
}

func (o *UpdateNetworkWirelessSsidOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response payload
	if err := consumer.Consume(response.Body(), &o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*UpdateNetworkWirelessSsidBody update network wireless ssid body
// Example: {"enabled":true,"name":"My SSID"}
swagger:model UpdateNetworkWirelessSsidBody
*/
type UpdateNetworkWirelessSsidBody struct {

	// active directory
	ActiveDirectory *UpdateNetworkWirelessSsidParamsBodyActiveDirectory `json:"activeDirectory,omitempty"`

	// Boolean indicating whether or not adult content will be blocked
	AdultContentFilteringEnabled bool `json:"adultContentFilteringEnabled,omitempty"`

	// The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
	ApTagsAndVlanIds []*UpdateNetworkWirelessSsidParamsBodyApTagsAndVlanIdsItems0 `json:"apTagsAndVlanIds"`

	// The association control method for the SSID ('open', 'open-enhanced', 'psk', 'open-with-radius', '8021x-meraki', '8021x-radius', '8021x-google', '8021x-localradius', 'ipsk-with-radius' or 'ipsk-without-radius')
	// Enum: [open open-enhanced psk open-with-radius 8021x-meraki 8021x-radius 8021x-google 8021x-localradius ipsk-with-radius ipsk-without-radius]
	AuthMode string `json:"authMode,omitempty"`

	// Accepts a list of tags for this SSID. If availableOnAllAps is false, then the SSID will only be broadcast by APs with tags matching any of the tags in this list.
	AvailabilityTags []string `json:"availabilityTags"`

	// Boolean indicating whether all APs should broadcast the SSID or if it should be restricted to APs matching any availability tags. Can only be false if the SSID has availability tags.
	AvailableOnAllAps bool `json:"availableOnAllAps,omitempty"`

	// The client-serving radio frequencies of this SSID in the default indoor RF profile. ('Dual band operation', '5 GHz band only' or 'Dual band operation with Band Steering')
	BandSelection string `json:"bandSelection,omitempty"`

	// The concentrator to use when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'.
	ConcentratorNetworkID string `json:"concentratorNetworkId,omitempty"`

	// The default VLAN ID used for 'all other APs'. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
	DefaultVlanID int64 `json:"defaultVlanId,omitempty"`

	// Disassociate clients when 'VPN' concentrator failover occurs in order to trigger clients to re-associate and generate new DHCP requests. This param is only valid if ipAssignmentMode is 'VPN'.
	DisassociateClientsOnVpnFailover bool `json:"disassociateClientsOnVpnFailover,omitempty"`

	// dns rewrite
	DNSRewrite *UpdateNetworkWirelessSsidParamsBodyDNSRewrite `json:"dnsRewrite,omitempty"`

	// dot11r
	Dot11r *UpdateNetworkWirelessSsidParamsBodyDot11r `json:"dot11r,omitempty"`

	// dot11w
	Dot11w *UpdateNetworkWirelessSsidParamsBodyDot11w `json:"dot11w,omitempty"`

	// Whether or not the SSID is enabled
	Enabled bool `json:"enabled,omitempty"`

	// The psk encryption mode for the SSID ('wep' or 'wpa'). This param is only valid if the authMode is 'psk'
	// Enum: [wep wpa]
	EncryptionMode string `json:"encryptionMode,omitempty"`

	// Whether or not an SSID is accessible by 'enterprise' administrators ('access disabled' or 'access enabled')
	// Enum: [access disabled access enabled]
	EnterpriseAdminAccess string `json:"enterpriseAdminAccess,omitempty"`

	// gre
	Gre *UpdateNetworkWirelessSsidParamsBodyGre `json:"gre,omitempty"`

	// The client IP assignment mode ('NAT mode', 'Bridge mode', 'Layer 3 roaming', 'Ethernet over GRE', 'Layer 3 roaming with a concentrator' or 'VPN')
	IPAssignmentMode string `json:"ipAssignmentMode,omitempty"`

	// Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is 'Bridge mode'.
	LanIsolationEnabled bool `json:"lanIsolationEnabled,omitempty"`

	// ldap
	Ldap *UpdateNetworkWirelessSsidParamsBodyLdap `json:"ldap,omitempty"`

	// local radius
	LocalRadius *UpdateNetworkWirelessSsidParamsBodyLocalRadius `json:"localRadius,omitempty"`

	// If true, Mandatory DHCP will enforce that clients connecting to this SSID must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate.
	MandatoryDhcpEnabled bool `json:"mandatoryDhcpEnabled,omitempty"`

	// The minimum bitrate in Mbps of this SSID in the default indoor RF profile. ('1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54')
	MinBitrate float32 `json:"minBitrate,omitempty"`

	// The name of the SSID
	Name string `json:"name,omitempty"`

	// oauth
	Oauth *UpdateNetworkWirelessSsidParamsBodyOauth `json:"oauth,omitempty"`

	// The download bandwidth limit in Kbps. (0 represents no limit.)
	PerClientBandwidthLimitDown int64 `json:"perClientBandwidthLimitDown,omitempty"`

	// The upload bandwidth limit in Kbps. (0 represents no limit.)
	PerClientBandwidthLimitUp int64 `json:"perClientBandwidthLimitUp,omitempty"`

	// The total download bandwidth limit in Kbps. (0 represents no limit.)
	PerSsidBandwidthLimitDown int64 `json:"perSsidBandwidthLimitDown,omitempty"`

	// The total upload bandwidth limit in Kbps. (0 represents no limit.)
	PerSsidBandwidthLimitUp int64 `json:"perSsidBandwidthLimitUp,omitempty"`

	// The passkey for the SSID. This param is only valid if the authMode is 'psk'
	Psk string `json:"psk,omitempty"`

	// Whether or not RADIUS accounting is enabled. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'
	RadiusAccountingEnabled bool `json:"radiusAccountingEnabled,omitempty"`

	// The interval (in seconds) in which accounting information is updated and sent to the RADIUS accounting server.
	RadiusAccountingInterimInterval int64 `json:"radiusAccountingInterimInterval,omitempty"`

	// The RADIUS accounting 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius' and radiusAccountingEnabled is 'true'
	RadiusAccountingServers []*UpdateNetworkWirelessSsidParamsBodyRadiusAccountingServersItems0 `json:"radiusAccountingServers"`

	// Specify the RADIUS attribute used to look up group policies ('Filter-Id', 'Reply-Message', 'Airespace-ACL-Name' or 'Aruba-User-Role'). Access points must receive this attribute in the RADIUS Access-Accept message
	// Enum: [Filter-Id Reply-Message Airespace-ACL-Name Aruba-User-Role]
	RadiusAttributeForGroupPolicies string `json:"radiusAttributeForGroupPolicies,omitempty"`

	// The template of the NAS identifier to be used for RADIUS authentication (ex. $NODE_MAC$:$VAP_NUM$).
	RadiusAuthenticationNasID string `json:"radiusAuthenticationNasId,omitempty"`

	// The template of the called station identifier to be used for RADIUS (ex. $NODE_MAC$:$VAP_NUM$).
	RadiusCalledStationID string `json:"radiusCalledStationId,omitempty"`

	// If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.
	RadiusCoaEnabled bool `json:"radiusCoaEnabled,omitempty"`

	// This policy determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable ('Deny access' or 'Allow access')
	// Enum: [Deny access Allow access]
	RadiusFailoverPolicy string `json:"radiusFailoverPolicy,omitempty"`

	// Whether or not higher priority RADIUS servers should be retried after 60 seconds.
	RadiusFallbackEnabled bool `json:"radiusFallbackEnabled,omitempty"`

	// Whether or not RADIUS Guest VLAN is enabled. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode
	RadiusGuestVlanEnabled bool `json:"radiusGuestVlanEnabled,omitempty"`

	// VLAN ID of the RADIUS Guest VLAN. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode
	RadiusGuestVlanID int64 `json:"radiusGuestVlanId,omitempty"`

	// This policy determines which RADIUS server will be contacted first in an authentication attempt and the ordering of any necessary retry attempts ('Strict priority order' or 'Round robin')
	// Enum: [Strict priority order Round robin]
	RadiusLoadBalancingPolicy string `json:"radiusLoadBalancingPolicy,omitempty"`

	// If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is 'NAT mode'.
	RadiusOverride bool `json:"radiusOverride,omitempty"`

	// If true, Meraki devices will proxy RADIUS messages through the Meraki cloud to the configured RADIUS auth and accounting servers.
	RadiusProxyEnabled bool `json:"radiusProxyEnabled,omitempty"`

	// The maximum number of transmit attempts after which a RADIUS server is failed over (must be between 1-5).
	RadiusServerAttemptsLimit int64 `json:"radiusServerAttemptsLimit,omitempty"`

	// The amount of time for which a RADIUS client waits for a reply from the RADIUS server (must be between 1-10 seconds).
	RadiusServerTimeout int64 `json:"radiusServerTimeout,omitempty"`

	// The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'
	RadiusServers []*UpdateNetworkWirelessSsidParamsBodyRadiusServersItems0 `json:"radiusServers"`

	// If true, Meraki devices will periodically send Access-Request messages to configured RADIUS servers using identity 'meraki_8021x_test' to ensure that the RADIUS servers are reachable.
	RadiusTestingEnabled bool `json:"radiusTestingEnabled,omitempty"`

	// The secondary concentrator to use when the ipAssignmentMode is 'VPN'. If configured, the APs will switch to using this concentrator if the primary concentrator is unreachable. This param is optional. ('disabled' represents no secondary concentrator.)
	SecondaryConcentratorNetworkID string `json:"secondaryConcentratorNetworkId,omitempty"`

	// speed burst
	SpeedBurst *UpdateNetworkWirelessSsidParamsBodySpeedBurst `json:"speedBurst,omitempty"`

	// Array of valid sponsor email domains for sponsored guest splash type.
	SplashGuestSponsorDomains []string `json:"splashGuestSponsorDomains"`

	// The type of splash page for the SSID ('None', 'Click-through splash page', 'Billing', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'SMS authentication', 'Systems Manager Sentry', 'Facebook Wi-Fi', 'Google OAuth', 'Sponsored guest', 'Cisco ISE' or 'Google Apps domain'). This attribute is not supported for template children.
	// Enum: [None Click-through splash page Billing Password-protected with Meraki RADIUS Password-protected with custom RADIUS Password-protected with Active Directory Password-protected with LDAP SMS authentication Systems Manager Sentry Facebook Wi-Fi Google OAuth Sponsored guest Cisco ISE Google Apps domain]
	SplashPage string `json:"splashPage,omitempty"`

	// Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
	UseVlanTagging bool `json:"useVlanTagging,omitempty"`

	// Boolean indicating whether APs should advertise or hide this SSID. APs will only broadcast this SSID if set to true
	Visible bool `json:"visible,omitempty"`

	// The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'
	VlanID int64 `json:"vlanId,omitempty"`

	// Allow access to a configurable list of IP ranges, which users may access prior to sign-on.
	WalledGardenEnabled bool `json:"walledGardenEnabled,omitempty"`

	// Specify your walled garden by entering an array of addresses, ranges using CIDR notation, domain names, and domain wildcards (e.g. '192.168.1.1/24', '192.168.37.10/32', 'www.yahoo.com', '*.google.com']). Meraki's splash page is automatically included in your walled garden.
	WalledGardenRanges []string `json:"walledGardenRanges"`

	// The types of WPA encryption. ('WPA1 only', 'WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode' or 'WPA3 only')
	// Enum: [WPA1 only WPA1 and WPA2 WPA2 only WPA3 Transition Mode WPA3 only]
	WpaEncryptionMode string `json:"wpaEncryptionMode,omitempty"`
}

// Validate validates this update network wireless ssid body
func (o *UpdateNetworkWirelessSsidBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateActiveDirectory(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateApTagsAndVlanIds(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAuthMode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDNSRewrite(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDot11r(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDot11w(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEncryptionMode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEnterpriseAdminAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGre(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLdap(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocalRadius(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOauth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRadiusAccountingServers(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRadiusAttributeForGroupPolicies(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRadiusFailoverPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRadiusLoadBalancingPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRadiusServers(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSpeedBurst(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSplashPage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWpaEncryptionMode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidBody) validateActiveDirectory(formats strfmt.Registry) error {
	if swag.IsZero(o.ActiveDirectory) { // not required
		return nil
	}

	if o.ActiveDirectory != nil {
		if err := o.ActiveDirectory.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "activeDirectory")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "activeDirectory")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) validateApTagsAndVlanIds(formats strfmt.Registry) error {
	if swag.IsZero(o.ApTagsAndVlanIds) { // not required
		return nil
	}

	for i := 0; i < len(o.ApTagsAndVlanIds); i++ {
		if swag.IsZero(o.ApTagsAndVlanIds[i]) { // not required
			continue
		}

		if o.ApTagsAndVlanIds[i] != nil {
			if err := o.ApTagsAndVlanIds[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("updateNetworkWirelessSsid" + "." + "apTagsAndVlanIds" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("updateNetworkWirelessSsid" + "." + "apTagsAndVlanIds" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var updateNetworkWirelessSsidBodyTypeAuthModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["open","open-enhanced","psk","open-with-radius","8021x-meraki","8021x-radius","8021x-google","8021x-localradius","ipsk-with-radius","ipsk-without-radius"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updateNetworkWirelessSsidBodyTypeAuthModePropEnum = append(updateNetworkWirelessSsidBodyTypeAuthModePropEnum, v)
	}
}

const (

	// UpdateNetworkWirelessSsidBodyAuthModeOpen captures enum value "open"
	UpdateNetworkWirelessSsidBodyAuthModeOpen string = "open"

	// UpdateNetworkWirelessSsidBodyAuthModeOpenDashEnhanced captures enum value "open-enhanced"
	UpdateNetworkWirelessSsidBodyAuthModeOpenDashEnhanced string = "open-enhanced"

	// UpdateNetworkWirelessSsidBodyAuthModePsk captures enum value "psk"
	UpdateNetworkWirelessSsidBodyAuthModePsk string = "psk"

	// UpdateNetworkWirelessSsidBodyAuthModeOpenDashWithDashRadius captures enum value "open-with-radius"
	UpdateNetworkWirelessSsidBodyAuthModeOpenDashWithDashRadius string = "open-with-radius"

	// UpdateNetworkWirelessSsidBodyAuthModeNr8021xDashMeraki captures enum value "8021x-meraki"
	UpdateNetworkWirelessSsidBodyAuthModeNr8021xDashMeraki string = "8021x-meraki"

	// UpdateNetworkWirelessSsidBodyAuthModeNr8021xDashRadius captures enum value "8021x-radius"
	UpdateNetworkWirelessSsidBodyAuthModeNr8021xDashRadius string = "8021x-radius"

	// UpdateNetworkWirelessSsidBodyAuthModeNr8021xDashGoogle captures enum value "8021x-google"
	UpdateNetworkWirelessSsidBodyAuthModeNr8021xDashGoogle string = "8021x-google"

	// UpdateNetworkWirelessSsidBodyAuthModeNr8021xDashLocalradius captures enum value "8021x-localradius"
	UpdateNetworkWirelessSsidBodyAuthModeNr8021xDashLocalradius string = "8021x-localradius"

	// UpdateNetworkWirelessSsidBodyAuthModeIpskDashWithDashRadius captures enum value "ipsk-with-radius"
	UpdateNetworkWirelessSsidBodyAuthModeIpskDashWithDashRadius string = "ipsk-with-radius"

	// UpdateNetworkWirelessSsidBodyAuthModeIpskDashWithoutDashRadius captures enum value "ipsk-without-radius"
	UpdateNetworkWirelessSsidBodyAuthModeIpskDashWithoutDashRadius string = "ipsk-without-radius"
)

// prop value enum
func (o *UpdateNetworkWirelessSsidBody) validateAuthModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, updateNetworkWirelessSsidBodyTypeAuthModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidBody) validateAuthMode(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthMode) { // not required
		return nil
	}

	// value enum
	if err := o.validateAuthModeEnum("updateNetworkWirelessSsid"+"."+"authMode", "body", o.AuthMode); err != nil {
		return err
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) validateDNSRewrite(formats strfmt.Registry) error {
	if swag.IsZero(o.DNSRewrite) { // not required
		return nil
	}

	if o.DNSRewrite != nil {
		if err := o.DNSRewrite.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "dnsRewrite")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "dnsRewrite")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) validateDot11r(formats strfmt.Registry) error {
	if swag.IsZero(o.Dot11r) { // not required
		return nil
	}

	if o.Dot11r != nil {
		if err := o.Dot11r.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "dot11r")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "dot11r")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) validateDot11w(formats strfmt.Registry) error {
	if swag.IsZero(o.Dot11w) { // not required
		return nil
	}

	if o.Dot11w != nil {
		if err := o.Dot11w.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "dot11w")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "dot11w")
			}
			return err
		}
	}

	return nil
}

var updateNetworkWirelessSsidBodyTypeEncryptionModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["wep","wpa"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updateNetworkWirelessSsidBodyTypeEncryptionModePropEnum = append(updateNetworkWirelessSsidBodyTypeEncryptionModePropEnum, v)
	}
}

const (

	// UpdateNetworkWirelessSsidBodyEncryptionModeWep captures enum value "wep"
	UpdateNetworkWirelessSsidBodyEncryptionModeWep string = "wep"

	// UpdateNetworkWirelessSsidBodyEncryptionModeWpa captures enum value "wpa"
	UpdateNetworkWirelessSsidBodyEncryptionModeWpa string = "wpa"
)

// prop value enum
func (o *UpdateNetworkWirelessSsidBody) validateEncryptionModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, updateNetworkWirelessSsidBodyTypeEncryptionModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidBody) validateEncryptionMode(formats strfmt.Registry) error {
	if swag.IsZero(o.EncryptionMode) { // not required
		return nil
	}

	// value enum
	if err := o.validateEncryptionModeEnum("updateNetworkWirelessSsid"+"."+"encryptionMode", "body", o.EncryptionMode); err != nil {
		return err
	}

	return nil
}

var updateNetworkWirelessSsidBodyTypeEnterpriseAdminAccessPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["access disabled","access enabled"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updateNetworkWirelessSsidBodyTypeEnterpriseAdminAccessPropEnum = append(updateNetworkWirelessSsidBodyTypeEnterpriseAdminAccessPropEnum, v)
	}
}

const (

	// UpdateNetworkWirelessSsidBodyEnterpriseAdminAccessAccessDisabled captures enum value "access disabled"
	UpdateNetworkWirelessSsidBodyEnterpriseAdminAccessAccessDisabled string = "access disabled"

	// UpdateNetworkWirelessSsidBodyEnterpriseAdminAccessAccessEnabled captures enum value "access enabled"
	UpdateNetworkWirelessSsidBodyEnterpriseAdminAccessAccessEnabled string = "access enabled"
)

// prop value enum
func (o *UpdateNetworkWirelessSsidBody) validateEnterpriseAdminAccessEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, updateNetworkWirelessSsidBodyTypeEnterpriseAdminAccessPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidBody) validateEnterpriseAdminAccess(formats strfmt.Registry) error {
	if swag.IsZero(o.EnterpriseAdminAccess) { // not required
		return nil
	}

	// value enum
	if err := o.validateEnterpriseAdminAccessEnum("updateNetworkWirelessSsid"+"."+"enterpriseAdminAccess", "body", o.EnterpriseAdminAccess); err != nil {
		return err
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) validateGre(formats strfmt.Registry) error {
	if swag.IsZero(o.Gre) { // not required
		return nil
	}

	if o.Gre != nil {
		if err := o.Gre.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "gre")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "gre")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) validateLdap(formats strfmt.Registry) error {
	if swag.IsZero(o.Ldap) { // not required
		return nil
	}

	if o.Ldap != nil {
		if err := o.Ldap.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "ldap")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "ldap")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) validateLocalRadius(formats strfmt.Registry) error {
	if swag.IsZero(o.LocalRadius) { // not required
		return nil
	}

	if o.LocalRadius != nil {
		if err := o.LocalRadius.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "localRadius")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "localRadius")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) validateOauth(formats strfmt.Registry) error {
	if swag.IsZero(o.Oauth) { // not required
		return nil
	}

	if o.Oauth != nil {
		if err := o.Oauth.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "oauth")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "oauth")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) validateRadiusAccountingServers(formats strfmt.Registry) error {
	if swag.IsZero(o.RadiusAccountingServers) { // not required
		return nil
	}

	for i := 0; i < len(o.RadiusAccountingServers); i++ {
		if swag.IsZero(o.RadiusAccountingServers[i]) { // not required
			continue
		}

		if o.RadiusAccountingServers[i] != nil {
			if err := o.RadiusAccountingServers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("updateNetworkWirelessSsid" + "." + "radiusAccountingServers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("updateNetworkWirelessSsid" + "." + "radiusAccountingServers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var updateNetworkWirelessSsidBodyTypeRadiusAttributeForGroupPoliciesPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Filter-Id","Reply-Message","Airespace-ACL-Name","Aruba-User-Role"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updateNetworkWirelessSsidBodyTypeRadiusAttributeForGroupPoliciesPropEnum = append(updateNetworkWirelessSsidBodyTypeRadiusAttributeForGroupPoliciesPropEnum, v)
	}
}

const (

	// UpdateNetworkWirelessSsidBodyRadiusAttributeForGroupPoliciesFilterDashID captures enum value "Filter-Id"
	UpdateNetworkWirelessSsidBodyRadiusAttributeForGroupPoliciesFilterDashID string = "Filter-Id"

	// UpdateNetworkWirelessSsidBodyRadiusAttributeForGroupPoliciesReplyDashMessage captures enum value "Reply-Message"
	UpdateNetworkWirelessSsidBodyRadiusAttributeForGroupPoliciesReplyDashMessage string = "Reply-Message"

	// UpdateNetworkWirelessSsidBodyRadiusAttributeForGroupPoliciesAirespaceDashACLDashName captures enum value "Airespace-ACL-Name"
	UpdateNetworkWirelessSsidBodyRadiusAttributeForGroupPoliciesAirespaceDashACLDashName string = "Airespace-ACL-Name"

	// UpdateNetworkWirelessSsidBodyRadiusAttributeForGroupPoliciesArubaDashUserDashRole captures enum value "Aruba-User-Role"
	UpdateNetworkWirelessSsidBodyRadiusAttributeForGroupPoliciesArubaDashUserDashRole string = "Aruba-User-Role"
)

// prop value enum
func (o *UpdateNetworkWirelessSsidBody) validateRadiusAttributeForGroupPoliciesEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, updateNetworkWirelessSsidBodyTypeRadiusAttributeForGroupPoliciesPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidBody) validateRadiusAttributeForGroupPolicies(formats strfmt.Registry) error {
	if swag.IsZero(o.RadiusAttributeForGroupPolicies) { // not required
		return nil
	}

	// value enum
	if err := o.validateRadiusAttributeForGroupPoliciesEnum("updateNetworkWirelessSsid"+"."+"radiusAttributeForGroupPolicies", "body", o.RadiusAttributeForGroupPolicies); err != nil {
		return err
	}

	return nil
}

var updateNetworkWirelessSsidBodyTypeRadiusFailoverPolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Deny access","Allow access"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updateNetworkWirelessSsidBodyTypeRadiusFailoverPolicyPropEnum = append(updateNetworkWirelessSsidBodyTypeRadiusFailoverPolicyPropEnum, v)
	}
}

const (

	// UpdateNetworkWirelessSsidBodyRadiusFailoverPolicyDenyAccess captures enum value "Deny access"
	UpdateNetworkWirelessSsidBodyRadiusFailoverPolicyDenyAccess string = "Deny access"

	// UpdateNetworkWirelessSsidBodyRadiusFailoverPolicyAllowAccess captures enum value "Allow access"
	UpdateNetworkWirelessSsidBodyRadiusFailoverPolicyAllowAccess string = "Allow access"
)

// prop value enum
func (o *UpdateNetworkWirelessSsidBody) validateRadiusFailoverPolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, updateNetworkWirelessSsidBodyTypeRadiusFailoverPolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidBody) validateRadiusFailoverPolicy(formats strfmt.Registry) error {
	if swag.IsZero(o.RadiusFailoverPolicy) { // not required
		return nil
	}

	// value enum
	if err := o.validateRadiusFailoverPolicyEnum("updateNetworkWirelessSsid"+"."+"radiusFailoverPolicy", "body", o.RadiusFailoverPolicy); err != nil {
		return err
	}

	return nil
}

var updateNetworkWirelessSsidBodyTypeRadiusLoadBalancingPolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Strict priority order","Round robin"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updateNetworkWirelessSsidBodyTypeRadiusLoadBalancingPolicyPropEnum = append(updateNetworkWirelessSsidBodyTypeRadiusLoadBalancingPolicyPropEnum, v)
	}
}

const (

	// UpdateNetworkWirelessSsidBodyRadiusLoadBalancingPolicyStrictPriorityOrder captures enum value "Strict priority order"
	UpdateNetworkWirelessSsidBodyRadiusLoadBalancingPolicyStrictPriorityOrder string = "Strict priority order"

	// UpdateNetworkWirelessSsidBodyRadiusLoadBalancingPolicyRoundRobin captures enum value "Round robin"
	UpdateNetworkWirelessSsidBodyRadiusLoadBalancingPolicyRoundRobin string = "Round robin"
)

// prop value enum
func (o *UpdateNetworkWirelessSsidBody) validateRadiusLoadBalancingPolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, updateNetworkWirelessSsidBodyTypeRadiusLoadBalancingPolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidBody) validateRadiusLoadBalancingPolicy(formats strfmt.Registry) error {
	if swag.IsZero(o.RadiusLoadBalancingPolicy) { // not required
		return nil
	}

	// value enum
	if err := o.validateRadiusLoadBalancingPolicyEnum("updateNetworkWirelessSsid"+"."+"radiusLoadBalancingPolicy", "body", o.RadiusLoadBalancingPolicy); err != nil {
		return err
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) validateRadiusServers(formats strfmt.Registry) error {
	if swag.IsZero(o.RadiusServers) { // not required
		return nil
	}

	for i := 0; i < len(o.RadiusServers); i++ {
		if swag.IsZero(o.RadiusServers[i]) { // not required
			continue
		}

		if o.RadiusServers[i] != nil {
			if err := o.RadiusServers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("updateNetworkWirelessSsid" + "." + "radiusServers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("updateNetworkWirelessSsid" + "." + "radiusServers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) validateSpeedBurst(formats strfmt.Registry) error {
	if swag.IsZero(o.SpeedBurst) { // not required
		return nil
	}

	if o.SpeedBurst != nil {
		if err := o.SpeedBurst.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "speedBurst")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "speedBurst")
			}
			return err
		}
	}

	return nil
}

var updateNetworkWirelessSsidBodyTypeSplashPagePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["None","Click-through splash page","Billing","Password-protected with Meraki RADIUS","Password-protected with custom RADIUS","Password-protected with Active Directory","Password-protected with LDAP","SMS authentication","Systems Manager Sentry","Facebook Wi-Fi","Google OAuth","Sponsored guest","Cisco ISE","Google Apps domain"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updateNetworkWirelessSsidBodyTypeSplashPagePropEnum = append(updateNetworkWirelessSsidBodyTypeSplashPagePropEnum, v)
	}
}

const (

	// UpdateNetworkWirelessSsidBodySplashPageNone captures enum value "None"
	UpdateNetworkWirelessSsidBodySplashPageNone string = "None"

	// UpdateNetworkWirelessSsidBodySplashPageClickDashThroughSplashPage captures enum value "Click-through splash page"
	UpdateNetworkWirelessSsidBodySplashPageClickDashThroughSplashPage string = "Click-through splash page"

	// UpdateNetworkWirelessSsidBodySplashPageBilling captures enum value "Billing"
	UpdateNetworkWirelessSsidBodySplashPageBilling string = "Billing"

	// UpdateNetworkWirelessSsidBodySplashPagePasswordDashProtectedWithMerakiRADIUS captures enum value "Password-protected with Meraki RADIUS"
	UpdateNetworkWirelessSsidBodySplashPagePasswordDashProtectedWithMerakiRADIUS string = "Password-protected with Meraki RADIUS"

	// UpdateNetworkWirelessSsidBodySplashPagePasswordDashProtectedWithCustomRADIUS captures enum value "Password-protected with custom RADIUS"
	UpdateNetworkWirelessSsidBodySplashPagePasswordDashProtectedWithCustomRADIUS string = "Password-protected with custom RADIUS"

	// UpdateNetworkWirelessSsidBodySplashPagePasswordDashProtectedWithActiveDirectory captures enum value "Password-protected with Active Directory"
	UpdateNetworkWirelessSsidBodySplashPagePasswordDashProtectedWithActiveDirectory string = "Password-protected with Active Directory"

	// UpdateNetworkWirelessSsidBodySplashPagePasswordDashProtectedWithLDAP captures enum value "Password-protected with LDAP"
	UpdateNetworkWirelessSsidBodySplashPagePasswordDashProtectedWithLDAP string = "Password-protected with LDAP"

	// UpdateNetworkWirelessSsidBodySplashPageSMSAuthentication captures enum value "SMS authentication"
	UpdateNetworkWirelessSsidBodySplashPageSMSAuthentication string = "SMS authentication"

	// UpdateNetworkWirelessSsidBodySplashPageSystemsManagerSentry captures enum value "Systems Manager Sentry"
	UpdateNetworkWirelessSsidBodySplashPageSystemsManagerSentry string = "Systems Manager Sentry"

	// UpdateNetworkWirelessSsidBodySplashPageFacebookWiDashFi captures enum value "Facebook Wi-Fi"
	UpdateNetworkWirelessSsidBodySplashPageFacebookWiDashFi string = "Facebook Wi-Fi"

	// UpdateNetworkWirelessSsidBodySplashPageGoogleOAuth captures enum value "Google OAuth"
	UpdateNetworkWirelessSsidBodySplashPageGoogleOAuth string = "Google OAuth"

	// UpdateNetworkWirelessSsidBodySplashPageSponsoredGuest captures enum value "Sponsored guest"
	UpdateNetworkWirelessSsidBodySplashPageSponsoredGuest string = "Sponsored guest"

	// UpdateNetworkWirelessSsidBodySplashPageCiscoISE captures enum value "Cisco ISE"
	UpdateNetworkWirelessSsidBodySplashPageCiscoISE string = "Cisco ISE"

	// UpdateNetworkWirelessSsidBodySplashPageGoogleAppsDomain captures enum value "Google Apps domain"
	UpdateNetworkWirelessSsidBodySplashPageGoogleAppsDomain string = "Google Apps domain"
)

// prop value enum
func (o *UpdateNetworkWirelessSsidBody) validateSplashPageEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, updateNetworkWirelessSsidBodyTypeSplashPagePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidBody) validateSplashPage(formats strfmt.Registry) error {
	if swag.IsZero(o.SplashPage) { // not required
		return nil
	}

	// value enum
	if err := o.validateSplashPageEnum("updateNetworkWirelessSsid"+"."+"splashPage", "body", o.SplashPage); err != nil {
		return err
	}

	return nil
}

var updateNetworkWirelessSsidBodyTypeWpaEncryptionModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["WPA1 only","WPA1 and WPA2","WPA2 only","WPA3 Transition Mode","WPA3 only"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updateNetworkWirelessSsidBodyTypeWpaEncryptionModePropEnum = append(updateNetworkWirelessSsidBodyTypeWpaEncryptionModePropEnum, v)
	}
}

const (

	// UpdateNetworkWirelessSsidBodyWpaEncryptionModeWPA1Only captures enum value "WPA1 only"
	UpdateNetworkWirelessSsidBodyWpaEncryptionModeWPA1Only string = "WPA1 only"

	// UpdateNetworkWirelessSsidBodyWpaEncryptionModeWPA1AndWPA2 captures enum value "WPA1 and WPA2"
	UpdateNetworkWirelessSsidBodyWpaEncryptionModeWPA1AndWPA2 string = "WPA1 and WPA2"

	// UpdateNetworkWirelessSsidBodyWpaEncryptionModeWPA2Only captures enum value "WPA2 only"
	UpdateNetworkWirelessSsidBodyWpaEncryptionModeWPA2Only string = "WPA2 only"

	// UpdateNetworkWirelessSsidBodyWpaEncryptionModeWPA3TransitionMode captures enum value "WPA3 Transition Mode"
	UpdateNetworkWirelessSsidBodyWpaEncryptionModeWPA3TransitionMode string = "WPA3 Transition Mode"

	// UpdateNetworkWirelessSsidBodyWpaEncryptionModeWPA3Only captures enum value "WPA3 only"
	UpdateNetworkWirelessSsidBodyWpaEncryptionModeWPA3Only string = "WPA3 only"
)

// prop value enum
func (o *UpdateNetworkWirelessSsidBody) validateWpaEncryptionModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, updateNetworkWirelessSsidBodyTypeWpaEncryptionModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidBody) validateWpaEncryptionMode(formats strfmt.Registry) error {
	if swag.IsZero(o.WpaEncryptionMode) { // not required
		return nil
	}

	// value enum
	if err := o.validateWpaEncryptionModeEnum("updateNetworkWirelessSsid"+"."+"wpaEncryptionMode", "body", o.WpaEncryptionMode); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this update network wireless ssid body based on the context it is used
func (o *UpdateNetworkWirelessSsidBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateActiveDirectory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateApTagsAndVlanIds(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateDNSRewrite(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateDot11r(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateDot11w(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateGre(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLdap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLocalRadius(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOauth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRadiusAccountingServers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRadiusServers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSpeedBurst(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidBody) contextValidateActiveDirectory(ctx context.Context, formats strfmt.Registry) error {

	if o.ActiveDirectory != nil {
		if err := o.ActiveDirectory.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "activeDirectory")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "activeDirectory")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) contextValidateApTagsAndVlanIds(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.ApTagsAndVlanIds); i++ {

		if o.ApTagsAndVlanIds[i] != nil {
			if err := o.ApTagsAndVlanIds[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("updateNetworkWirelessSsid" + "." + "apTagsAndVlanIds" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("updateNetworkWirelessSsid" + "." + "apTagsAndVlanIds" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) contextValidateDNSRewrite(ctx context.Context, formats strfmt.Registry) error {

	if o.DNSRewrite != nil {
		if err := o.DNSRewrite.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "dnsRewrite")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "dnsRewrite")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) contextValidateDot11r(ctx context.Context, formats strfmt.Registry) error {

	if o.Dot11r != nil {
		if err := o.Dot11r.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "dot11r")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "dot11r")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) contextValidateDot11w(ctx context.Context, formats strfmt.Registry) error {

	if o.Dot11w != nil {
		if err := o.Dot11w.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "dot11w")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "dot11w")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) contextValidateGre(ctx context.Context, formats strfmt.Registry) error {

	if o.Gre != nil {
		if err := o.Gre.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "gre")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "gre")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) contextValidateLdap(ctx context.Context, formats strfmt.Registry) error {

	if o.Ldap != nil {
		if err := o.Ldap.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "ldap")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "ldap")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) contextValidateLocalRadius(ctx context.Context, formats strfmt.Registry) error {

	if o.LocalRadius != nil {
		if err := o.LocalRadius.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "localRadius")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "localRadius")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) contextValidateOauth(ctx context.Context, formats strfmt.Registry) error {

	if o.Oauth != nil {
		if err := o.Oauth.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "oauth")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "oauth")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) contextValidateRadiusAccountingServers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.RadiusAccountingServers); i++ {

		if o.RadiusAccountingServers[i] != nil {
			if err := o.RadiusAccountingServers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("updateNetworkWirelessSsid" + "." + "radiusAccountingServers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("updateNetworkWirelessSsid" + "." + "radiusAccountingServers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) contextValidateRadiusServers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.RadiusServers); i++ {

		if o.RadiusServers[i] != nil {
			if err := o.RadiusServers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("updateNetworkWirelessSsid" + "." + "radiusServers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("updateNetworkWirelessSsid" + "." + "radiusServers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *UpdateNetworkWirelessSsidBody) contextValidateSpeedBurst(ctx context.Context, formats strfmt.Registry) error {

	if o.SpeedBurst != nil {
		if err := o.SpeedBurst.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "speedBurst")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "speedBurst")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidBody) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodyActiveDirectory The current setting for Active Directory. Only valid if splashPage is 'Password-protected with Active Directory'
swagger:model UpdateNetworkWirelessSsidParamsBodyActiveDirectory
*/
type UpdateNetworkWirelessSsidParamsBodyActiveDirectory struct {

	// credentials
	Credentials *UpdateNetworkWirelessSsidParamsBodyActiveDirectoryCredentials `json:"credentials,omitempty"`

	// The Active Directory servers to be used for authentication.
	Servers []*UpdateNetworkWirelessSsidParamsBodyActiveDirectoryServersItems0 `json:"servers"`
}

// Validate validates this update network wireless ssid params body active directory
func (o *UpdateNetworkWirelessSsidParamsBodyActiveDirectory) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCredentials(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateServers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyActiveDirectory) validateCredentials(formats strfmt.Registry) error {
	if swag.IsZero(o.Credentials) { // not required
		return nil
	}

	if o.Credentials != nil {
		if err := o.Credentials.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "activeDirectory" + "." + "credentials")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "activeDirectory" + "." + "credentials")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyActiveDirectory) validateServers(formats strfmt.Registry) error {
	if swag.IsZero(o.Servers) { // not required
		return nil
	}

	for i := 0; i < len(o.Servers); i++ {
		if swag.IsZero(o.Servers[i]) { // not required
			continue
		}

		if o.Servers[i] != nil {
			if err := o.Servers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("updateNetworkWirelessSsid" + "." + "activeDirectory" + "." + "servers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("updateNetworkWirelessSsid" + "." + "activeDirectory" + "." + "servers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this update network wireless ssid params body active directory based on the context it is used
func (o *UpdateNetworkWirelessSsidParamsBodyActiveDirectory) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCredentials(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateServers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyActiveDirectory) contextValidateCredentials(ctx context.Context, formats strfmt.Registry) error {

	if o.Credentials != nil {
		if err := o.Credentials.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "activeDirectory" + "." + "credentials")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "activeDirectory" + "." + "credentials")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyActiveDirectory) contextValidateServers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Servers); i++ {

		if o.Servers[i] != nil {
			if err := o.Servers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("updateNetworkWirelessSsid" + "." + "activeDirectory" + "." + "servers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("updateNetworkWirelessSsid" + "." + "activeDirectory" + "." + "servers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyActiveDirectory) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyActiveDirectory) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodyActiveDirectory
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodyActiveDirectoryCredentials (Optional) The credentials of the user account to be used by the AP to bind to your Active Directory server. The Active Directory account should have permissions on all your Active Directory servers. Only valid if the splashPage is 'Password-protected with Active Directory'.
swagger:model UpdateNetworkWirelessSsidParamsBodyActiveDirectoryCredentials
*/
type UpdateNetworkWirelessSsidParamsBodyActiveDirectoryCredentials struct {

	// The logon name of the Active Directory account.
	LogonName string `json:"logonName,omitempty"`

	// The password to the Active Directory user account.
	Password string `json:"password,omitempty"`
}

// Validate validates this update network wireless ssid params body active directory credentials
func (o *UpdateNetworkWirelessSsidParamsBodyActiveDirectoryCredentials) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this update network wireless ssid params body active directory credentials based on context it is used
func (o *UpdateNetworkWirelessSsidParamsBodyActiveDirectoryCredentials) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyActiveDirectoryCredentials) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyActiveDirectoryCredentials) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodyActiveDirectoryCredentials
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodyActiveDirectoryServersItems0 update network wireless ssid params body active directory servers items0
swagger:model UpdateNetworkWirelessSsidParamsBodyActiveDirectoryServersItems0
*/
type UpdateNetworkWirelessSsidParamsBodyActiveDirectoryServersItems0 struct {

	// IP address of your Active Directory server.
	// Required: true
	Host *string `json:"host"`

	// (Optional) UDP port the Active Directory server listens on. By default, uses port 3268.
	Port int64 `json:"port,omitempty"`
}

// Validate validates this update network wireless ssid params body active directory servers items0
func (o *UpdateNetworkWirelessSsidParamsBodyActiveDirectoryServersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateHost(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyActiveDirectoryServersItems0) validateHost(formats strfmt.Registry) error {

	if err := validate.Required("host", "body", o.Host); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this update network wireless ssid params body active directory servers items0 based on context it is used
func (o *UpdateNetworkWirelessSsidParamsBodyActiveDirectoryServersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyActiveDirectoryServersItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyActiveDirectoryServersItems0) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodyActiveDirectoryServersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodyApTagsAndVlanIdsItems0 update network wireless ssid params body ap tags and vlan ids items0
swagger:model UpdateNetworkWirelessSsidParamsBodyApTagsAndVlanIdsItems0
*/
type UpdateNetworkWirelessSsidParamsBodyApTagsAndVlanIdsItems0 struct {

	// Array of AP tags
	Tags []string `json:"tags"`

	// Numerical identifier that is assigned to the VLAN
	VlanID int64 `json:"vlanId,omitempty"`
}

// Validate validates this update network wireless ssid params body ap tags and vlan ids items0
func (o *UpdateNetworkWirelessSsidParamsBodyApTagsAndVlanIdsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this update network wireless ssid params body ap tags and vlan ids items0 based on context it is used
func (o *UpdateNetworkWirelessSsidParamsBodyApTagsAndVlanIdsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyApTagsAndVlanIdsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyApTagsAndVlanIdsItems0) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodyApTagsAndVlanIdsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodyDNSRewrite DNS servers rewrite settings
swagger:model UpdateNetworkWirelessSsidParamsBodyDNSRewrite
*/
type UpdateNetworkWirelessSsidParamsBodyDNSRewrite struct {

	// User specified DNS servers (up to two servers)
	DNSCustomNameservers []string `json:"dnsCustomNameservers"`

	// Boolean indicating whether or not DNS server rewrite is enabled. If disabled, upstream DNS will be used
	Enabled bool `json:"enabled,omitempty"`
}

// Validate validates this update network wireless ssid params body DNS rewrite
func (o *UpdateNetworkWirelessSsidParamsBodyDNSRewrite) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this update network wireless ssid params body DNS rewrite based on context it is used
func (o *UpdateNetworkWirelessSsidParamsBodyDNSRewrite) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyDNSRewrite) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyDNSRewrite) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodyDNSRewrite
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodyDot11r The current setting for 802.11r
swagger:model UpdateNetworkWirelessSsidParamsBodyDot11r
*/
type UpdateNetworkWirelessSsidParamsBodyDot11r struct {

	// (Optional) Whether 802.11r is adaptive or not.
	Adaptive bool `json:"adaptive,omitempty"`

	// Whether 802.11r is enabled or not.
	Enabled bool `json:"enabled,omitempty"`
}

// Validate validates this update network wireless ssid params body dot11r
func (o *UpdateNetworkWirelessSsidParamsBodyDot11r) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this update network wireless ssid params body dot11r based on context it is used
func (o *UpdateNetworkWirelessSsidParamsBodyDot11r) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyDot11r) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyDot11r) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodyDot11r
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodyDot11w The current setting for Protected Management Frames (802.11w).
swagger:model UpdateNetworkWirelessSsidParamsBodyDot11w
*/
type UpdateNetworkWirelessSsidParamsBodyDot11w struct {

	// Whether 802.11w is enabled or not.
	Enabled bool `json:"enabled,omitempty"`

	// (Optional) Whether 802.11w is required or not.
	Required bool `json:"required,omitempty"`
}

// Validate validates this update network wireless ssid params body dot11w
func (o *UpdateNetworkWirelessSsidParamsBodyDot11w) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this update network wireless ssid params body dot11w based on context it is used
func (o *UpdateNetworkWirelessSsidParamsBodyDot11w) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyDot11w) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyDot11w) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodyDot11w
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodyGre Ethernet over GRE settings
swagger:model UpdateNetworkWirelessSsidParamsBodyGre
*/
type UpdateNetworkWirelessSsidParamsBodyGre struct {

	// concentrator
	Concentrator *UpdateNetworkWirelessSsidParamsBodyGreConcentrator `json:"concentrator,omitempty"`

	// Optional numerical identifier that will add the GRE key field to the GRE header. Used to identify an individual traffic flow within a tunnel.
	Key int64 `json:"key,omitempty"`
}

// Validate validates this update network wireless ssid params body gre
func (o *UpdateNetworkWirelessSsidParamsBodyGre) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateConcentrator(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyGre) validateConcentrator(formats strfmt.Registry) error {
	if swag.IsZero(o.Concentrator) { // not required
		return nil
	}

	if o.Concentrator != nil {
		if err := o.Concentrator.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "gre" + "." + "concentrator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "gre" + "." + "concentrator")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this update network wireless ssid params body gre based on the context it is used
func (o *UpdateNetworkWirelessSsidParamsBodyGre) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateConcentrator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyGre) contextValidateConcentrator(ctx context.Context, formats strfmt.Registry) error {

	if o.Concentrator != nil {
		if err := o.Concentrator.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "gre" + "." + "concentrator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "gre" + "." + "concentrator")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyGre) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyGre) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodyGre
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodyGreConcentrator The EoGRE concentrator's settings
swagger:model UpdateNetworkWirelessSsidParamsBodyGreConcentrator
*/
type UpdateNetworkWirelessSsidParamsBodyGreConcentrator struct {

	// The EoGRE concentrator's IP or FQDN. This param is required when ipAssignmentMode is 'Ethernet over GRE'.
	// Required: true
	Host *string `json:"host"`
}

// Validate validates this update network wireless ssid params body gre concentrator
func (o *UpdateNetworkWirelessSsidParamsBodyGreConcentrator) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateHost(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyGreConcentrator) validateHost(formats strfmt.Registry) error {

	if err := validate.Required("updateNetworkWirelessSsid"+"."+"gre"+"."+"concentrator"+"."+"host", "body", o.Host); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this update network wireless ssid params body gre concentrator based on context it is used
func (o *UpdateNetworkWirelessSsidParamsBodyGreConcentrator) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyGreConcentrator) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyGreConcentrator) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodyGreConcentrator
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodyLdap The current setting for LDAP. Only valid if splashPage is 'Password-protected with LDAP'.
swagger:model UpdateNetworkWirelessSsidParamsBodyLdap
*/
type UpdateNetworkWirelessSsidParamsBodyLdap struct {

	// The base distinguished name of users on the LDAP server.
	BaseDistinguishedName string `json:"baseDistinguishedName,omitempty"`

	// credentials
	Credentials *UpdateNetworkWirelessSsidParamsBodyLdapCredentials `json:"credentials,omitempty"`

	// server ca certificate
	ServerCaCertificate *UpdateNetworkWirelessSsidParamsBodyLdapServerCaCertificate `json:"serverCaCertificate,omitempty"`

	// The LDAP servers to be used for authentication.
	Servers []*UpdateNetworkWirelessSsidParamsBodyLdapServersItems0 `json:"servers"`
}

// Validate validates this update network wireless ssid params body ldap
func (o *UpdateNetworkWirelessSsidParamsBodyLdap) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCredentials(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateServerCaCertificate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateServers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyLdap) validateCredentials(formats strfmt.Registry) error {
	if swag.IsZero(o.Credentials) { // not required
		return nil
	}

	if o.Credentials != nil {
		if err := o.Credentials.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "ldap" + "." + "credentials")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "ldap" + "." + "credentials")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyLdap) validateServerCaCertificate(formats strfmt.Registry) error {
	if swag.IsZero(o.ServerCaCertificate) { // not required
		return nil
	}

	if o.ServerCaCertificate != nil {
		if err := o.ServerCaCertificate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "ldap" + "." + "serverCaCertificate")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "ldap" + "." + "serverCaCertificate")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyLdap) validateServers(formats strfmt.Registry) error {
	if swag.IsZero(o.Servers) { // not required
		return nil
	}

	for i := 0; i < len(o.Servers); i++ {
		if swag.IsZero(o.Servers[i]) { // not required
			continue
		}

		if o.Servers[i] != nil {
			if err := o.Servers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("updateNetworkWirelessSsid" + "." + "ldap" + "." + "servers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("updateNetworkWirelessSsid" + "." + "ldap" + "." + "servers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this update network wireless ssid params body ldap based on the context it is used
func (o *UpdateNetworkWirelessSsidParamsBodyLdap) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCredentials(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateServerCaCertificate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateServers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyLdap) contextValidateCredentials(ctx context.Context, formats strfmt.Registry) error {

	if o.Credentials != nil {
		if err := o.Credentials.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "ldap" + "." + "credentials")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "ldap" + "." + "credentials")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyLdap) contextValidateServerCaCertificate(ctx context.Context, formats strfmt.Registry) error {

	if o.ServerCaCertificate != nil {
		if err := o.ServerCaCertificate.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "ldap" + "." + "serverCaCertificate")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "ldap" + "." + "serverCaCertificate")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyLdap) contextValidateServers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Servers); i++ {

		if o.Servers[i] != nil {
			if err := o.Servers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("updateNetworkWirelessSsid" + "." + "ldap" + "." + "servers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("updateNetworkWirelessSsid" + "." + "ldap" + "." + "servers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyLdap) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyLdap) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodyLdap
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodyLdapCredentials (Optional) The credentials of the user account to be used by the AP to bind to your LDAP server. The LDAP account should have permissions on all your LDAP servers.
swagger:model UpdateNetworkWirelessSsidParamsBodyLdapCredentials
*/
type UpdateNetworkWirelessSsidParamsBodyLdapCredentials struct {

	// The distinguished name of the LDAP user account (example: cn=user,dc=meraki,dc=com).
	DistinguishedName string `json:"distinguishedName,omitempty"`

	// The password of the LDAP user account.
	Password string `json:"password,omitempty"`
}

// Validate validates this update network wireless ssid params body ldap credentials
func (o *UpdateNetworkWirelessSsidParamsBodyLdapCredentials) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this update network wireless ssid params body ldap credentials based on context it is used
func (o *UpdateNetworkWirelessSsidParamsBodyLdapCredentials) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyLdapCredentials) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyLdapCredentials) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodyLdapCredentials
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodyLdapServerCaCertificate The CA certificate used to sign the LDAP server's key.
swagger:model UpdateNetworkWirelessSsidParamsBodyLdapServerCaCertificate
*/
type UpdateNetworkWirelessSsidParamsBodyLdapServerCaCertificate struct {

	// The contents of the CA certificate. Must be in PEM or DER format.
	Contents string `json:"contents,omitempty"`
}

// Validate validates this update network wireless ssid params body ldap server ca certificate
func (o *UpdateNetworkWirelessSsidParamsBodyLdapServerCaCertificate) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this update network wireless ssid params body ldap server ca certificate based on context it is used
func (o *UpdateNetworkWirelessSsidParamsBodyLdapServerCaCertificate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyLdapServerCaCertificate) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyLdapServerCaCertificate) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodyLdapServerCaCertificate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodyLdapServersItems0 update network wireless ssid params body ldap servers items0
swagger:model UpdateNetworkWirelessSsidParamsBodyLdapServersItems0
*/
type UpdateNetworkWirelessSsidParamsBodyLdapServersItems0 struct {

	// IP address of your LDAP server.
	// Required: true
	Host *string `json:"host"`

	// UDP port the LDAP server listens on.
	// Required: true
	Port *int64 `json:"port"`
}

// Validate validates this update network wireless ssid params body ldap servers items0
func (o *UpdateNetworkWirelessSsidParamsBodyLdapServersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateHost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePort(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyLdapServersItems0) validateHost(formats strfmt.Registry) error {

	if err := validate.Required("host", "body", o.Host); err != nil {
		return err
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyLdapServersItems0) validatePort(formats strfmt.Registry) error {

	if err := validate.Required("port", "body", o.Port); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this update network wireless ssid params body ldap servers items0 based on context it is used
func (o *UpdateNetworkWirelessSsidParamsBodyLdapServersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyLdapServersItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyLdapServersItems0) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodyLdapServersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodyLocalRadius The current setting for Local Authentication, a built-in RADIUS server on the access point. Only valid if authMode is '8021x-localradius'.
swagger:model UpdateNetworkWirelessSsidParamsBodyLocalRadius
*/
type UpdateNetworkWirelessSsidParamsBodyLocalRadius struct {

	// The duration (in seconds) for which LDAP and OCSP lookups are cached.
	CacheTimeout int64 `json:"cacheTimeout,omitempty"`

	// certificate authentication
	CertificateAuthentication *UpdateNetworkWirelessSsidParamsBodyLocalRadiusCertificateAuthentication `json:"certificateAuthentication,omitempty"`

	// password authentication
	PasswordAuthentication *UpdateNetworkWirelessSsidParamsBodyLocalRadiusPasswordAuthentication `json:"passwordAuthentication,omitempty"`
}

// Validate validates this update network wireless ssid params body local radius
func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadius) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCertificateAuthentication(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePasswordAuthentication(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadius) validateCertificateAuthentication(formats strfmt.Registry) error {
	if swag.IsZero(o.CertificateAuthentication) { // not required
		return nil
	}

	if o.CertificateAuthentication != nil {
		if err := o.CertificateAuthentication.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "localRadius" + "." + "certificateAuthentication")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "localRadius" + "." + "certificateAuthentication")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadius) validatePasswordAuthentication(formats strfmt.Registry) error {
	if swag.IsZero(o.PasswordAuthentication) { // not required
		return nil
	}

	if o.PasswordAuthentication != nil {
		if err := o.PasswordAuthentication.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "localRadius" + "." + "passwordAuthentication")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "localRadius" + "." + "passwordAuthentication")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this update network wireless ssid params body local radius based on the context it is used
func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadius) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCertificateAuthentication(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePasswordAuthentication(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadius) contextValidateCertificateAuthentication(ctx context.Context, formats strfmt.Registry) error {

	if o.CertificateAuthentication != nil {
		if err := o.CertificateAuthentication.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "localRadius" + "." + "certificateAuthentication")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "localRadius" + "." + "certificateAuthentication")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadius) contextValidatePasswordAuthentication(ctx context.Context, formats strfmt.Registry) error {

	if o.PasswordAuthentication != nil {
		if err := o.PasswordAuthentication.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "localRadius" + "." + "passwordAuthentication")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "localRadius" + "." + "passwordAuthentication")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadius) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadius) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodyLocalRadius
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodyLocalRadiusCertificateAuthentication The current setting for certificate verification.
swagger:model UpdateNetworkWirelessSsidParamsBodyLocalRadiusCertificateAuthentication
*/
type UpdateNetworkWirelessSsidParamsBodyLocalRadiusCertificateAuthentication struct {

	// client root ca certificate
	ClientRootCaCertificate *UpdateNetworkWirelessSsidParamsBodyLocalRadiusCertificateAuthenticationClientRootCaCertificate `json:"clientRootCaCertificate,omitempty"`

	// Whether or not to use EAP-TLS certificate-based authentication to validate wireless clients.
	Enabled bool `json:"enabled,omitempty"`

	// (Optional) The URL of the OCSP responder to verify client certificate status.
	OcspResponderURL string `json:"ocspResponderUrl,omitempty"`

	// Whether or not to verify the certificate with LDAP.
	UseLdap bool `json:"useLdap,omitempty"`

	// Whether or not to verify the certificate with OCSP.
	UseOcsp bool `json:"useOcsp,omitempty"`
}

// Validate validates this update network wireless ssid params body local radius certificate authentication
func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadiusCertificateAuthentication) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateClientRootCaCertificate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadiusCertificateAuthentication) validateClientRootCaCertificate(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientRootCaCertificate) { // not required
		return nil
	}

	if o.ClientRootCaCertificate != nil {
		if err := o.ClientRootCaCertificate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "localRadius" + "." + "certificateAuthentication" + "." + "clientRootCaCertificate")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "localRadius" + "." + "certificateAuthentication" + "." + "clientRootCaCertificate")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this update network wireless ssid params body local radius certificate authentication based on the context it is used
func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadiusCertificateAuthentication) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateClientRootCaCertificate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadiusCertificateAuthentication) contextValidateClientRootCaCertificate(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientRootCaCertificate != nil {
		if err := o.ClientRootCaCertificate.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateNetworkWirelessSsid" + "." + "localRadius" + "." + "certificateAuthentication" + "." + "clientRootCaCertificate")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateNetworkWirelessSsid" + "." + "localRadius" + "." + "certificateAuthentication" + "." + "clientRootCaCertificate")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadiusCertificateAuthentication) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadiusCertificateAuthentication) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodyLocalRadiusCertificateAuthentication
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodyLocalRadiusCertificateAuthenticationClientRootCaCertificate The Client CA Certificate used to sign the client certificate.
swagger:model UpdateNetworkWirelessSsidParamsBodyLocalRadiusCertificateAuthenticationClientRootCaCertificate
*/
type UpdateNetworkWirelessSsidParamsBodyLocalRadiusCertificateAuthenticationClientRootCaCertificate struct {

	// The contents of the Client CA Certificate. Must be in PEM or DER format.
	Contents string `json:"contents,omitempty"`
}

// Validate validates this update network wireless ssid params body local radius certificate authentication client root ca certificate
func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadiusCertificateAuthenticationClientRootCaCertificate) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this update network wireless ssid params body local radius certificate authentication client root ca certificate based on context it is used
func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadiusCertificateAuthenticationClientRootCaCertificate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadiusCertificateAuthenticationClientRootCaCertificate) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadiusCertificateAuthenticationClientRootCaCertificate) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodyLocalRadiusCertificateAuthenticationClientRootCaCertificate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodyLocalRadiusPasswordAuthentication The current setting for password-based authentication.
swagger:model UpdateNetworkWirelessSsidParamsBodyLocalRadiusPasswordAuthentication
*/
type UpdateNetworkWirelessSsidParamsBodyLocalRadiusPasswordAuthentication struct {

	// Whether or not to use EAP-TTLS/PAP or PEAP-GTC password-based authentication via LDAP lookup.
	Enabled bool `json:"enabled,omitempty"`
}

// Validate validates this update network wireless ssid params body local radius password authentication
func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadiusPasswordAuthentication) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this update network wireless ssid params body local radius password authentication based on context it is used
func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadiusPasswordAuthentication) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadiusPasswordAuthentication) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyLocalRadiusPasswordAuthentication) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodyLocalRadiusPasswordAuthentication
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodyOauth The OAuth settings of this SSID. Only valid if splashPage is 'Google OAuth'.
swagger:model UpdateNetworkWirelessSsidParamsBodyOauth
*/
type UpdateNetworkWirelessSsidParamsBodyOauth struct {

	// (Optional) The list of domains allowed access to the network.
	AllowedDomains []string `json:"allowedDomains"`
}

// Validate validates this update network wireless ssid params body oauth
func (o *UpdateNetworkWirelessSsidParamsBodyOauth) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this update network wireless ssid params body oauth based on context it is used
func (o *UpdateNetworkWirelessSsidParamsBodyOauth) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyOauth) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyOauth) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodyOauth
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodyRadiusAccountingServersItems0 update network wireless ssid params body radius accounting servers items0
swagger:model UpdateNetworkWirelessSsidParamsBodyRadiusAccountingServersItems0
*/
type UpdateNetworkWirelessSsidParamsBodyRadiusAccountingServersItems0 struct {

	// Certificate used for authorization for the RADSEC Server
	CaCertificate string `json:"caCertificate,omitempty"`

	// IP address to which the APs will send RADIUS accounting messages
	// Required: true
	Host *string `json:"host"`

	// Port on the RADIUS server that is listening for accounting messages
	Port int64 `json:"port,omitempty"`

	// Use RADSEC (TLS over TCP) to connect to this RADIUS accounting server. Requires radiusProxyEnabled.
	RadsecEnabled bool `json:"radsecEnabled,omitempty"`

	// Shared key used to authenticate messages between the APs and RADIUS server
	Secret string `json:"secret,omitempty"`
}

// Validate validates this update network wireless ssid params body radius accounting servers items0
func (o *UpdateNetworkWirelessSsidParamsBodyRadiusAccountingServersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateHost(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyRadiusAccountingServersItems0) validateHost(formats strfmt.Registry) error {

	if err := validate.Required("host", "body", o.Host); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this update network wireless ssid params body radius accounting servers items0 based on context it is used
func (o *UpdateNetworkWirelessSsidParamsBodyRadiusAccountingServersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyRadiusAccountingServersItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyRadiusAccountingServersItems0) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodyRadiusAccountingServersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodyRadiusServersItems0 update network wireless ssid params body radius servers items0
swagger:model UpdateNetworkWirelessSsidParamsBodyRadiusServersItems0
*/
type UpdateNetworkWirelessSsidParamsBodyRadiusServersItems0 struct {

	// Certificate used for authorization for the RADSEC Server
	CaCertificate string `json:"caCertificate,omitempty"`

	// IP address of your RADIUS server
	// Required: true
	Host *string `json:"host"`

	// The ID of the Openroaming Certificate attached to radius server.
	OpenRoamingCertificateID int64 `json:"openRoamingCertificateId,omitempty"`

	// UDP port the RADIUS server listens on for Access-requests
	Port int64 `json:"port,omitempty"`

	// Use RADSEC (TLS over TCP) to connect to this RADIUS server. Requires radiusProxyEnabled.
	RadsecEnabled bool `json:"radsecEnabled,omitempty"`

	// RADIUS client shared secret
	Secret string `json:"secret,omitempty"`
}

// Validate validates this update network wireless ssid params body radius servers items0
func (o *UpdateNetworkWirelessSsidParamsBodyRadiusServersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateHost(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateNetworkWirelessSsidParamsBodyRadiusServersItems0) validateHost(formats strfmt.Registry) error {

	if err := validate.Required("host", "body", o.Host); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this update network wireless ssid params body radius servers items0 based on context it is used
func (o *UpdateNetworkWirelessSsidParamsBodyRadiusServersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyRadiusServersItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodyRadiusServersItems0) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodyRadiusServersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*UpdateNetworkWirelessSsidParamsBodySpeedBurst The SpeedBurst setting for this SSID'
swagger:model UpdateNetworkWirelessSsidParamsBodySpeedBurst
*/
type UpdateNetworkWirelessSsidParamsBodySpeedBurst struct {

	// Boolean indicating whether or not to allow users to temporarily exceed the bandwidth limit for short periods while still keeping them under the bandwidth limit over time.
	Enabled bool `json:"enabled,omitempty"`
}

// Validate validates this update network wireless ssid params body speed burst
func (o *UpdateNetworkWirelessSsidParamsBodySpeedBurst) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this update network wireless ssid params body speed burst based on context it is used
func (o *UpdateNetworkWirelessSsidParamsBodySpeedBurst) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodySpeedBurst) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateNetworkWirelessSsidParamsBodySpeedBurst) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkWirelessSsidParamsBodySpeedBurst
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

// Code generated by go-swagger; DO NOT EDIT.

package networks

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CreateNetworkGroupPolicyReader is a Reader for the CreateNetworkGroupPolicy structure.
type CreateNetworkGroupPolicyReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *CreateNetworkGroupPolicyReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewCreateNetworkGroupPolicyCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewCreateNetworkGroupPolicyCreated creates a CreateNetworkGroupPolicyCreated with default headers values
func NewCreateNetworkGroupPolicyCreated() *CreateNetworkGroupPolicyCreated {
	return &CreateNetworkGroupPolicyCreated{}
}

/* CreateNetworkGroupPolicyCreated describes a response with status code 201, with default header values.

Successful operation
*/
type CreateNetworkGroupPolicyCreated struct {
	Payload interface{}
}

func (o *CreateNetworkGroupPolicyCreated) Error() string {
	return fmt.Sprintf("[POST /networks/{networkId}/groupPolicies][%d] createNetworkGroupPolicyCreated  %+v", 201, o.Payload)
}
func (o *CreateNetworkGroupPolicyCreated) GetPayload() interface{} {
	return o.Payload
}

func (o *CreateNetworkGroupPolicyCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response payload
	if err := consumer.Consume(response.Body(), &o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*CreateNetworkGroupPolicyBody create network group policy body
// Example: {"bandwidth":{"bandwidthLimits":{"limitDown":1000000,"limitUp":1000000},"settings":"custom"},"bonjourForwarding":{"rules":[{"description":"A simple bonjour rule","services":["All Services"],"vlanId":"1"}],"settings":"custom"},"contentFiltering":{"allowedUrlPatterns":{"patterns":[],"settings":"network default"},"blockedUrlCategories":{"categories":["meraki:contentFiltering/category/1","meraki:contentFiltering/category/7"],"settings":"override"},"blockedUrlPatterns":{"patterns":["http://www.example.com","http://www.betting.com"],"settings":"append"}},"firewallAndTrafficShaping":{"l3FirewallRules":[{"comment":"Allow TCP traffic to subnet with HTTP servers.","destCidr":"192.168.1.0/24","destPort":"443","policy":"allow","protocol":"tcp"}],"l7FirewallRules":[{"policy":"deny","type":"host","value":"google.com"},{"policy":"deny","type":"port","value":"23"},{"policy":"deny","type":"ipRange","value":"10.11.12.00/24"},{"policy":"deny","type":"ipRange","value":"10.11.12.00/24:5555"}],"settings":"custom","trafficShapingRules":[{"definitions":[{"type":"host","value":"google.com"},{"type":"port","value":"9090"},{"type":"ipRange","value":"192.1.0.0"},{"type":"ipRange","value":"192.1.0.0/16"},{"type":"ipRange","value":"10.1.0.0/16:80"},{"type":"localNet","value":"192.168.0.0/16"}],"dscpTagValue":0,"pcpTagValue":0,"perClientBandwidthLimits":{"bandwidthLimits":{"limitDown":1000000,"limitUp":1000000},"settings":"custom"}}]},"name":"No video streaming","scheduling":{"enabled":true,"friday":{"active":true,"from":"9:00","to":"17:00"},"monday":{"active":true,"from":"9:00","to":"17:00"},"saturday":{"active":false,"from":"0:00","to":"24:00"},"sunday":{"active":false,"from":"0:00","to":"24:00"},"thursday":{"active":true,"from":"9:00","to":"17:00"},"tuesday":{"active":true,"from":"9:00","to":"17:00"},"wednesday":{"active":true,"from":"9:00","to":"17:00"}},"splashAuthSettings":"bypass","vlanTagging":{"settings":"custom","vlanId":"1"}}
swagger:model CreateNetworkGroupPolicyBody
*/
type CreateNetworkGroupPolicyBody struct {

	// bandwidth
	Bandwidth *CreateNetworkGroupPolicyParamsBodyBandwidth `json:"bandwidth,omitempty"`

	// bonjour forwarding
	BonjourForwarding *CreateNetworkGroupPolicyParamsBodyBonjourForwarding `json:"bonjourForwarding,omitempty"`

	// content filtering
	ContentFiltering *CreateNetworkGroupPolicyParamsBodyContentFiltering `json:"contentFiltering,omitempty"`

	// firewall and traffic shaping
	FirewallAndTrafficShaping *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShaping `json:"firewallAndTrafficShaping,omitempty"`

	// The name for your group policy. Required.
	// Required: true
	Name *string `json:"name"`

	// scheduling
	Scheduling *CreateNetworkGroupPolicyParamsBodyScheduling `json:"scheduling,omitempty"`

	// Whether clients bound to your policy will bypass splash authorization or behave according to the network's rules. Can be one of 'network default' or 'bypass'. Only available if your network has a wireless configuration.
	// Enum: [network default bypass]
	SplashAuthSettings string `json:"splashAuthSettings,omitempty"`

	// vlan tagging
	VlanTagging *CreateNetworkGroupPolicyParamsBodyVlanTagging `json:"vlanTagging,omitempty"`
}

// Validate validates this create network group policy body
func (o *CreateNetworkGroupPolicyBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBandwidth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBonjourForwarding(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateContentFiltering(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirewallAndTrafficShaping(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateScheduling(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSplashAuthSettings(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVlanTagging(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateNetworkGroupPolicyBody) validateBandwidth(formats strfmt.Registry) error {
	if swag.IsZero(o.Bandwidth) { // not required
		return nil
	}

	if o.Bandwidth != nil {
		if err := o.Bandwidth.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "bandwidth")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "bandwidth")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyBody) validateBonjourForwarding(formats strfmt.Registry) error {
	if swag.IsZero(o.BonjourForwarding) { // not required
		return nil
	}

	if o.BonjourForwarding != nil {
		if err := o.BonjourForwarding.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "bonjourForwarding")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "bonjourForwarding")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyBody) validateContentFiltering(formats strfmt.Registry) error {
	if swag.IsZero(o.ContentFiltering) { // not required
		return nil
	}

	if o.ContentFiltering != nil {
		if err := o.ContentFiltering.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "contentFiltering")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "contentFiltering")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyBody) validateFirewallAndTrafficShaping(formats strfmt.Registry) error {
	if swag.IsZero(o.FirewallAndTrafficShaping) { // not required
		return nil
	}

	if o.FirewallAndTrafficShaping != nil {
		if err := o.FirewallAndTrafficShaping.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "firewallAndTrafficShaping")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "firewallAndTrafficShaping")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyBody) validateName(formats strfmt.Registry) error {

	if err := validate.Required("createNetworkGroupPolicy"+"."+"name", "body", o.Name); err != nil {
		return err
	}

	return nil
}

func (o *CreateNetworkGroupPolicyBody) validateScheduling(formats strfmt.Registry) error {
	if swag.IsZero(o.Scheduling) { // not required
		return nil
	}

	if o.Scheduling != nil {
		if err := o.Scheduling.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "scheduling")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "scheduling")
			}
			return err
		}
	}

	return nil
}

var createNetworkGroupPolicyBodyTypeSplashAuthSettingsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["network default","bypass"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createNetworkGroupPolicyBodyTypeSplashAuthSettingsPropEnum = append(createNetworkGroupPolicyBodyTypeSplashAuthSettingsPropEnum, v)
	}
}

const (

	// CreateNetworkGroupPolicyBodySplashAuthSettingsNetworkDefault captures enum value "network default"
	CreateNetworkGroupPolicyBodySplashAuthSettingsNetworkDefault string = "network default"

	// CreateNetworkGroupPolicyBodySplashAuthSettingsBypass captures enum value "bypass"
	CreateNetworkGroupPolicyBodySplashAuthSettingsBypass string = "bypass"
)

// prop value enum
func (o *CreateNetworkGroupPolicyBody) validateSplashAuthSettingsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createNetworkGroupPolicyBodyTypeSplashAuthSettingsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *CreateNetworkGroupPolicyBody) validateSplashAuthSettings(formats strfmt.Registry) error {
	if swag.IsZero(o.SplashAuthSettings) { // not required
		return nil
	}

	// value enum
	if err := o.validateSplashAuthSettingsEnum("createNetworkGroupPolicy"+"."+"splashAuthSettings", "body", o.SplashAuthSettings); err != nil {
		return err
	}

	return nil
}

func (o *CreateNetworkGroupPolicyBody) validateVlanTagging(formats strfmt.Registry) error {
	if swag.IsZero(o.VlanTagging) { // not required
		return nil
	}

	if o.VlanTagging != nil {
		if err := o.VlanTagging.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "vlanTagging")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "vlanTagging")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create network group policy body based on the context it is used
func (o *CreateNetworkGroupPolicyBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBandwidth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBonjourForwarding(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateContentFiltering(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateFirewallAndTrafficShaping(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateScheduling(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateVlanTagging(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateNetworkGroupPolicyBody) contextValidateBandwidth(ctx context.Context, formats strfmt.Registry) error {

	if o.Bandwidth != nil {
		if err := o.Bandwidth.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "bandwidth")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "bandwidth")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyBody) contextValidateBonjourForwarding(ctx context.Context, formats strfmt.Registry) error {

	if o.BonjourForwarding != nil {
		if err := o.BonjourForwarding.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "bonjourForwarding")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "bonjourForwarding")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyBody) contextValidateContentFiltering(ctx context.Context, formats strfmt.Registry) error {

	if o.ContentFiltering != nil {
		if err := o.ContentFiltering.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "contentFiltering")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "contentFiltering")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyBody) contextValidateFirewallAndTrafficShaping(ctx context.Context, formats strfmt.Registry) error {

	if o.FirewallAndTrafficShaping != nil {
		if err := o.FirewallAndTrafficShaping.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "firewallAndTrafficShaping")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "firewallAndTrafficShaping")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyBody) contextValidateScheduling(ctx context.Context, formats strfmt.Registry) error {

	if o.Scheduling != nil {
		if err := o.Scheduling.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "scheduling")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "scheduling")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyBody) contextValidateVlanTagging(ctx context.Context, formats strfmt.Registry) error {

	if o.VlanTagging != nil {
		if err := o.VlanTagging.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "vlanTagging")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "vlanTagging")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyBody) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodyBandwidth     The bandwidth settings for clients bound to your group policy.
//
swagger:model CreateNetworkGroupPolicyParamsBodyBandwidth
*/
type CreateNetworkGroupPolicyParamsBodyBandwidth struct {

	// bandwidth limits
	BandwidthLimits *CreateNetworkGroupPolicyParamsBodyBandwidthBandwidthLimits `json:"bandwidthLimits,omitempty"`

	// How bandwidth limits are enforced. Can be 'network default', 'ignore' or 'custom'.
	// Enum: [network default ignore custom]
	Settings string `json:"settings,omitempty"`
}

// Validate validates this create network group policy params body bandwidth
func (o *CreateNetworkGroupPolicyParamsBodyBandwidth) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBandwidthLimits(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSettings(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyBandwidth) validateBandwidthLimits(formats strfmt.Registry) error {
	if swag.IsZero(o.BandwidthLimits) { // not required
		return nil
	}

	if o.BandwidthLimits != nil {
		if err := o.BandwidthLimits.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "bandwidth" + "." + "bandwidthLimits")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "bandwidth" + "." + "bandwidthLimits")
			}
			return err
		}
	}

	return nil
}

var createNetworkGroupPolicyParamsBodyBandwidthTypeSettingsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["network default","ignore","custom"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createNetworkGroupPolicyParamsBodyBandwidthTypeSettingsPropEnum = append(createNetworkGroupPolicyParamsBodyBandwidthTypeSettingsPropEnum, v)
	}
}

const (

	// CreateNetworkGroupPolicyParamsBodyBandwidthSettingsNetworkDefault captures enum value "network default"
	CreateNetworkGroupPolicyParamsBodyBandwidthSettingsNetworkDefault string = "network default"

	// CreateNetworkGroupPolicyParamsBodyBandwidthSettingsIgnore captures enum value "ignore"
	CreateNetworkGroupPolicyParamsBodyBandwidthSettingsIgnore string = "ignore"

	// CreateNetworkGroupPolicyParamsBodyBandwidthSettingsCustom captures enum value "custom"
	CreateNetworkGroupPolicyParamsBodyBandwidthSettingsCustom string = "custom"
)

// prop value enum
func (o *CreateNetworkGroupPolicyParamsBodyBandwidth) validateSettingsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createNetworkGroupPolicyParamsBodyBandwidthTypeSettingsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyBandwidth) validateSettings(formats strfmt.Registry) error {
	if swag.IsZero(o.Settings) { // not required
		return nil
	}

	// value enum
	if err := o.validateSettingsEnum("createNetworkGroupPolicy"+"."+"bandwidth"+"."+"settings", "body", o.Settings); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create network group policy params body bandwidth based on the context it is used
func (o *CreateNetworkGroupPolicyParamsBodyBandwidth) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBandwidthLimits(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyBandwidth) contextValidateBandwidthLimits(ctx context.Context, formats strfmt.Registry) error {

	if o.BandwidthLimits != nil {
		if err := o.BandwidthLimits.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "bandwidth" + "." + "bandwidthLimits")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "bandwidth" + "." + "bandwidthLimits")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyBandwidth) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyBandwidth) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodyBandwidth
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodyBandwidthBandwidthLimits The bandwidth limits object, specifying upload and download speed for clients bound to the group policy. These are only enforced if 'settings' is set to 'custom'.
swagger:model CreateNetworkGroupPolicyParamsBodyBandwidthBandwidthLimits
*/
type CreateNetworkGroupPolicyParamsBodyBandwidthBandwidthLimits struct {

	// The maximum download limit (integer, in Kbps). null indicates no limit
	LimitDown int64 `json:"limitDown,omitempty"`

	// The maximum upload limit (integer, in Kbps). null indicates no limit
	LimitUp int64 `json:"limitUp,omitempty"`
}

// Validate validates this create network group policy params body bandwidth bandwidth limits
func (o *CreateNetworkGroupPolicyParamsBodyBandwidthBandwidthLimits) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create network group policy params body bandwidth bandwidth limits based on context it is used
func (o *CreateNetworkGroupPolicyParamsBodyBandwidthBandwidthLimits) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyBandwidthBandwidthLimits) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyBandwidthBandwidthLimits) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodyBandwidthBandwidthLimits
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodyBonjourForwarding The Bonjour settings for your group policy. Only valid if your network has a wireless configuration.
swagger:model CreateNetworkGroupPolicyParamsBodyBonjourForwarding
*/
type CreateNetworkGroupPolicyParamsBodyBonjourForwarding struct {

	// A list of the Bonjour forwarding rules for your group policy. If 'settings' is set to 'custom', at least one rule must be specified.
	Rules []*CreateNetworkGroupPolicyParamsBodyBonjourForwardingRulesItems0 `json:"rules"`

	// How Bonjour rules are applied. Can be 'network default', 'ignore' or 'custom'.
	// Enum: [network default ignore custom]
	Settings string `json:"settings,omitempty"`
}

// Validate validates this create network group policy params body bonjour forwarding
func (o *CreateNetworkGroupPolicyParamsBodyBonjourForwarding) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateRules(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSettings(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyBonjourForwarding) validateRules(formats strfmt.Registry) error {
	if swag.IsZero(o.Rules) { // not required
		return nil
	}

	for i := 0; i < len(o.Rules); i++ {
		if swag.IsZero(o.Rules[i]) { // not required
			continue
		}

		if o.Rules[i] != nil {
			if err := o.Rules[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createNetworkGroupPolicy" + "." + "bonjourForwarding" + "." + "rules" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createNetworkGroupPolicy" + "." + "bonjourForwarding" + "." + "rules" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var createNetworkGroupPolicyParamsBodyBonjourForwardingTypeSettingsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["network default","ignore","custom"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createNetworkGroupPolicyParamsBodyBonjourForwardingTypeSettingsPropEnum = append(createNetworkGroupPolicyParamsBodyBonjourForwardingTypeSettingsPropEnum, v)
	}
}

const (

	// CreateNetworkGroupPolicyParamsBodyBonjourForwardingSettingsNetworkDefault captures enum value "network default"
	CreateNetworkGroupPolicyParamsBodyBonjourForwardingSettingsNetworkDefault string = "network default"

	// CreateNetworkGroupPolicyParamsBodyBonjourForwardingSettingsIgnore captures enum value "ignore"
	CreateNetworkGroupPolicyParamsBodyBonjourForwardingSettingsIgnore string = "ignore"

	// CreateNetworkGroupPolicyParamsBodyBonjourForwardingSettingsCustom captures enum value "custom"
	CreateNetworkGroupPolicyParamsBodyBonjourForwardingSettingsCustom string = "custom"
)

// prop value enum
func (o *CreateNetworkGroupPolicyParamsBodyBonjourForwarding) validateSettingsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createNetworkGroupPolicyParamsBodyBonjourForwardingTypeSettingsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyBonjourForwarding) validateSettings(formats strfmt.Registry) error {
	if swag.IsZero(o.Settings) { // not required
		return nil
	}

	// value enum
	if err := o.validateSettingsEnum("createNetworkGroupPolicy"+"."+"bonjourForwarding"+"."+"settings", "body", o.Settings); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create network group policy params body bonjour forwarding based on the context it is used
func (o *CreateNetworkGroupPolicyParamsBodyBonjourForwarding) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateRules(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyBonjourForwarding) contextValidateRules(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Rules); i++ {

		if o.Rules[i] != nil {
			if err := o.Rules[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createNetworkGroupPolicy" + "." + "bonjourForwarding" + "." + "rules" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createNetworkGroupPolicy" + "." + "bonjourForwarding" + "." + "rules" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyBonjourForwarding) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyBonjourForwarding) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodyBonjourForwarding
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodyBonjourForwardingRulesItems0 create network group policy params body bonjour forwarding rules items0
swagger:model CreateNetworkGroupPolicyParamsBodyBonjourForwardingRulesItems0
*/
type CreateNetworkGroupPolicyParamsBodyBonjourForwardingRulesItems0 struct {

	// A description for your Bonjour forwarding rule. Optional.
	Description string `json:"description,omitempty"`

	// A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
	// Required: true
	Services []string `json:"services"`

	// The ID of the service VLAN. Required.
	// Required: true
	VlanID *string `json:"vlanId"`
}

// Validate validates this create network group policy params body bonjour forwarding rules items0
func (o *CreateNetworkGroupPolicyParamsBodyBonjourForwardingRulesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateServices(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVlanID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var createNetworkGroupPolicyParamsBodyBonjourForwardingRulesItems0ServicesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["All Services","AirPlay","AFP","BitTorrent","FTP","iChat","iTunes","Printers","Samba","Scanners","SSH"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createNetworkGroupPolicyParamsBodyBonjourForwardingRulesItems0ServicesItemsEnum = append(createNetworkGroupPolicyParamsBodyBonjourForwardingRulesItems0ServicesItemsEnum, v)
	}
}

func (o *CreateNetworkGroupPolicyParamsBodyBonjourForwardingRulesItems0) validateServicesItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createNetworkGroupPolicyParamsBodyBonjourForwardingRulesItems0ServicesItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyBonjourForwardingRulesItems0) validateServices(formats strfmt.Registry) error {

	if err := validate.Required("services", "body", o.Services); err != nil {
		return err
	}

	for i := 0; i < len(o.Services); i++ {

		// value enum
		if err := o.validateServicesItemsEnum("services"+"."+strconv.Itoa(i), "body", o.Services[i]); err != nil {
			return err
		}

	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyBonjourForwardingRulesItems0) validateVlanID(formats strfmt.Registry) error {

	if err := validate.Required("vlanId", "body", o.VlanID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create network group policy params body bonjour forwarding rules items0 based on context it is used
func (o *CreateNetworkGroupPolicyParamsBodyBonjourForwardingRulesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyBonjourForwardingRulesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyBonjourForwardingRulesItems0) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodyBonjourForwardingRulesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodyContentFiltering The content filtering settings for your group policy
swagger:model CreateNetworkGroupPolicyParamsBodyContentFiltering
*/
type CreateNetworkGroupPolicyParamsBodyContentFiltering struct {

	// allowed Url patterns
	AllowedURLPatterns *CreateNetworkGroupPolicyParamsBodyContentFilteringAllowedURLPatterns `json:"allowedUrlPatterns,omitempty"`

	// blocked Url categories
	BlockedURLCategories *CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLCategories `json:"blockedUrlCategories,omitempty"`

	// blocked Url patterns
	BlockedURLPatterns *CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLPatterns `json:"blockedUrlPatterns,omitempty"`
}

// Validate validates this create network group policy params body content filtering
func (o *CreateNetworkGroupPolicyParamsBodyContentFiltering) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAllowedURLPatterns(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBlockedURLCategories(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBlockedURLPatterns(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyContentFiltering) validateAllowedURLPatterns(formats strfmt.Registry) error {
	if swag.IsZero(o.AllowedURLPatterns) { // not required
		return nil
	}

	if o.AllowedURLPatterns != nil {
		if err := o.AllowedURLPatterns.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "contentFiltering" + "." + "allowedUrlPatterns")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "contentFiltering" + "." + "allowedUrlPatterns")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyContentFiltering) validateBlockedURLCategories(formats strfmt.Registry) error {
	if swag.IsZero(o.BlockedURLCategories) { // not required
		return nil
	}

	if o.BlockedURLCategories != nil {
		if err := o.BlockedURLCategories.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "contentFiltering" + "." + "blockedUrlCategories")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "contentFiltering" + "." + "blockedUrlCategories")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyContentFiltering) validateBlockedURLPatterns(formats strfmt.Registry) error {
	if swag.IsZero(o.BlockedURLPatterns) { // not required
		return nil
	}

	if o.BlockedURLPatterns != nil {
		if err := o.BlockedURLPatterns.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "contentFiltering" + "." + "blockedUrlPatterns")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "contentFiltering" + "." + "blockedUrlPatterns")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create network group policy params body content filtering based on the context it is used
func (o *CreateNetworkGroupPolicyParamsBodyContentFiltering) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAllowedURLPatterns(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBlockedURLCategories(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBlockedURLPatterns(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyContentFiltering) contextValidateAllowedURLPatterns(ctx context.Context, formats strfmt.Registry) error {

	if o.AllowedURLPatterns != nil {
		if err := o.AllowedURLPatterns.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "contentFiltering" + "." + "allowedUrlPatterns")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "contentFiltering" + "." + "allowedUrlPatterns")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyContentFiltering) contextValidateBlockedURLCategories(ctx context.Context, formats strfmt.Registry) error {

	if o.BlockedURLCategories != nil {
		if err := o.BlockedURLCategories.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "contentFiltering" + "." + "blockedUrlCategories")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "contentFiltering" + "." + "blockedUrlCategories")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyContentFiltering) contextValidateBlockedURLPatterns(ctx context.Context, formats strfmt.Registry) error {

	if o.BlockedURLPatterns != nil {
		if err := o.BlockedURLPatterns.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "contentFiltering" + "." + "blockedUrlPatterns")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "contentFiltering" + "." + "blockedUrlPatterns")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyContentFiltering) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyContentFiltering) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodyContentFiltering
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodyContentFilteringAllowedURLPatterns Settings for allowed URL patterns
swagger:model CreateNetworkGroupPolicyParamsBodyContentFilteringAllowedURLPatterns
*/
type CreateNetworkGroupPolicyParamsBodyContentFilteringAllowedURLPatterns struct {

	// A list of URL patterns that are allowed
	Patterns []string `json:"patterns"`

	// How URL patterns are applied. Can be 'network default', 'append' or 'override'.
	// Enum: [network default append override]
	Settings string `json:"settings,omitempty"`
}

// Validate validates this create network group policy params body content filtering allowed URL patterns
func (o *CreateNetworkGroupPolicyParamsBodyContentFilteringAllowedURLPatterns) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSettings(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var createNetworkGroupPolicyParamsBodyContentFilteringAllowedUrlPatternsTypeSettingsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["network default","append","override"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createNetworkGroupPolicyParamsBodyContentFilteringAllowedUrlPatternsTypeSettingsPropEnum = append(createNetworkGroupPolicyParamsBodyContentFilteringAllowedUrlPatternsTypeSettingsPropEnum, v)
	}
}

const (

	// CreateNetworkGroupPolicyParamsBodyContentFilteringAllowedURLPatternsSettingsNetworkDefault captures enum value "network default"
	CreateNetworkGroupPolicyParamsBodyContentFilteringAllowedURLPatternsSettingsNetworkDefault string = "network default"

	// CreateNetworkGroupPolicyParamsBodyContentFilteringAllowedURLPatternsSettingsAppend captures enum value "append"
	CreateNetworkGroupPolicyParamsBodyContentFilteringAllowedURLPatternsSettingsAppend string = "append"

	// CreateNetworkGroupPolicyParamsBodyContentFilteringAllowedURLPatternsSettingsOverride captures enum value "override"
	CreateNetworkGroupPolicyParamsBodyContentFilteringAllowedURLPatternsSettingsOverride string = "override"
)

// prop value enum
func (o *CreateNetworkGroupPolicyParamsBodyContentFilteringAllowedURLPatterns) validateSettingsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createNetworkGroupPolicyParamsBodyContentFilteringAllowedUrlPatternsTypeSettingsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyContentFilteringAllowedURLPatterns) validateSettings(formats strfmt.Registry) error {
	if swag.IsZero(o.Settings) { // not required
		return nil
	}

	// value enum
	if err := o.validateSettingsEnum("createNetworkGroupPolicy"+"."+"contentFiltering"+"."+"allowedUrlPatterns"+"."+"settings", "body", o.Settings); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create network group policy params body content filtering allowed URL patterns based on context it is used
func (o *CreateNetworkGroupPolicyParamsBodyContentFilteringAllowedURLPatterns) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyContentFilteringAllowedURLPatterns) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyContentFilteringAllowedURLPatterns) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodyContentFilteringAllowedURLPatterns
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLCategories Settings for blocked URL categories
swagger:model CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLCategories
*/
type CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLCategories struct {

	// A list of URL categories to block
	Categories []string `json:"categories"`

	// How URL categories are applied. Can be 'network default', 'append' or 'override'.
	// Enum: [network default append override]
	Settings string `json:"settings,omitempty"`
}

// Validate validates this create network group policy params body content filtering blocked URL categories
func (o *CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLCategories) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSettings(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var createNetworkGroupPolicyParamsBodyContentFilteringBlockedUrlCategoriesTypeSettingsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["network default","append","override"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createNetworkGroupPolicyParamsBodyContentFilteringBlockedUrlCategoriesTypeSettingsPropEnum = append(createNetworkGroupPolicyParamsBodyContentFilteringBlockedUrlCategoriesTypeSettingsPropEnum, v)
	}
}

const (

	// CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLCategoriesSettingsNetworkDefault captures enum value "network default"
	CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLCategoriesSettingsNetworkDefault string = "network default"

	// CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLCategoriesSettingsAppend captures enum value "append"
	CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLCategoriesSettingsAppend string = "append"

	// CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLCategoriesSettingsOverride captures enum value "override"
	CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLCategoriesSettingsOverride string = "override"
)

// prop value enum
func (o *CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLCategories) validateSettingsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createNetworkGroupPolicyParamsBodyContentFilteringBlockedUrlCategoriesTypeSettingsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLCategories) validateSettings(formats strfmt.Registry) error {
	if swag.IsZero(o.Settings) { // not required
		return nil
	}

	// value enum
	if err := o.validateSettingsEnum("createNetworkGroupPolicy"+"."+"contentFiltering"+"."+"blockedUrlCategories"+"."+"settings", "body", o.Settings); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create network group policy params body content filtering blocked URL categories based on context it is used
func (o *CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLCategories) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLCategories) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLCategories) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLCategories
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLPatterns Settings for blocked URL patterns
swagger:model CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLPatterns
*/
type CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLPatterns struct {

	// A list of URL patterns that are blocked
	Patterns []string `json:"patterns"`

	// How URL patterns are applied. Can be 'network default', 'append' or 'override'.
	// Enum: [network default append override]
	Settings string `json:"settings,omitempty"`
}

// Validate validates this create network group policy params body content filtering blocked URL patterns
func (o *CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLPatterns) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSettings(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var createNetworkGroupPolicyParamsBodyContentFilteringBlockedUrlPatternsTypeSettingsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["network default","append","override"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createNetworkGroupPolicyParamsBodyContentFilteringBlockedUrlPatternsTypeSettingsPropEnum = append(createNetworkGroupPolicyParamsBodyContentFilteringBlockedUrlPatternsTypeSettingsPropEnum, v)
	}
}

const (

	// CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLPatternsSettingsNetworkDefault captures enum value "network default"
	CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLPatternsSettingsNetworkDefault string = "network default"

	// CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLPatternsSettingsAppend captures enum value "append"
	CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLPatternsSettingsAppend string = "append"

	// CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLPatternsSettingsOverride captures enum value "override"
	CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLPatternsSettingsOverride string = "override"
)

// prop value enum
func (o *CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLPatterns) validateSettingsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createNetworkGroupPolicyParamsBodyContentFilteringBlockedUrlPatternsTypeSettingsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLPatterns) validateSettings(formats strfmt.Registry) error {
	if swag.IsZero(o.Settings) { // not required
		return nil
	}

	// value enum
	if err := o.validateSettingsEnum("createNetworkGroupPolicy"+"."+"contentFiltering"+"."+"blockedUrlPatterns"+"."+"settings", "body", o.Settings); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create network group policy params body content filtering blocked URL patterns based on context it is used
func (o *CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLPatterns) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLPatterns) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLPatterns) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodyContentFilteringBlockedURLPatterns
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShaping     The firewall and traffic shaping rules and settings for your policy.
//
swagger:model CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShaping
*/
type CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShaping struct {

	// An ordered array of the L3 firewall rules
	L3FirewallRules []*CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL3FirewallRulesItems0 `json:"l3FirewallRules"`

	// An ordered array of L7 firewall rules
	L7FirewallRules []*CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0 `json:"l7FirewallRules"`

	// How firewall and traffic shaping rules are enforced. Can be 'network default', 'ignore' or 'custom'.
	// Enum: [network default ignore custom]
	Settings string `json:"settings,omitempty"`

	//     An array of traffic shaping rules. Rules are applied in the order that
	//     they are specified in. An empty list (or null) means no rules. Note that
	//     you are allowed a maximum of 8 rules.
	//
	TrafficShapingRules []*CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0 `json:"trafficShapingRules"`
}

// Validate validates this create network group policy params body firewall and traffic shaping
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShaping) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateL3FirewallRules(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateL7FirewallRules(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSettings(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTrafficShapingRules(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShaping) validateL3FirewallRules(formats strfmt.Registry) error {
	if swag.IsZero(o.L3FirewallRules) { // not required
		return nil
	}

	for i := 0; i < len(o.L3FirewallRules); i++ {
		if swag.IsZero(o.L3FirewallRules[i]) { // not required
			continue
		}

		if o.L3FirewallRules[i] != nil {
			if err := o.L3FirewallRules[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createNetworkGroupPolicy" + "." + "firewallAndTrafficShaping" + "." + "l3FirewallRules" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createNetworkGroupPolicy" + "." + "firewallAndTrafficShaping" + "." + "l3FirewallRules" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShaping) validateL7FirewallRules(formats strfmt.Registry) error {
	if swag.IsZero(o.L7FirewallRules) { // not required
		return nil
	}

	for i := 0; i < len(o.L7FirewallRules); i++ {
		if swag.IsZero(o.L7FirewallRules[i]) { // not required
			continue
		}

		if o.L7FirewallRules[i] != nil {
			if err := o.L7FirewallRules[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createNetworkGroupPolicy" + "." + "firewallAndTrafficShaping" + "." + "l7FirewallRules" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createNetworkGroupPolicy" + "." + "firewallAndTrafficShaping" + "." + "l7FirewallRules" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var createNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTypeSettingsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["network default","ignore","custom"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTypeSettingsPropEnum = append(createNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTypeSettingsPropEnum, v)
	}
}

const (

	// CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingSettingsNetworkDefault captures enum value "network default"
	CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingSettingsNetworkDefault string = "network default"

	// CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingSettingsIgnore captures enum value "ignore"
	CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingSettingsIgnore string = "ignore"

	// CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingSettingsCustom captures enum value "custom"
	CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingSettingsCustom string = "custom"
)

// prop value enum
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShaping) validateSettingsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTypeSettingsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShaping) validateSettings(formats strfmt.Registry) error {
	if swag.IsZero(o.Settings) { // not required
		return nil
	}

	// value enum
	if err := o.validateSettingsEnum("createNetworkGroupPolicy"+"."+"firewallAndTrafficShaping"+"."+"settings", "body", o.Settings); err != nil {
		return err
	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShaping) validateTrafficShapingRules(formats strfmt.Registry) error {
	if swag.IsZero(o.TrafficShapingRules) { // not required
		return nil
	}

	for i := 0; i < len(o.TrafficShapingRules); i++ {
		if swag.IsZero(o.TrafficShapingRules[i]) { // not required
			continue
		}

		if o.TrafficShapingRules[i] != nil {
			if err := o.TrafficShapingRules[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createNetworkGroupPolicy" + "." + "firewallAndTrafficShaping" + "." + "trafficShapingRules" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createNetworkGroupPolicy" + "." + "firewallAndTrafficShaping" + "." + "trafficShapingRules" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this create network group policy params body firewall and traffic shaping based on the context it is used
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShaping) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateL3FirewallRules(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateL7FirewallRules(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTrafficShapingRules(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShaping) contextValidateL3FirewallRules(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.L3FirewallRules); i++ {

		if o.L3FirewallRules[i] != nil {
			if err := o.L3FirewallRules[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createNetworkGroupPolicy" + "." + "firewallAndTrafficShaping" + "." + "l3FirewallRules" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createNetworkGroupPolicy" + "." + "firewallAndTrafficShaping" + "." + "l3FirewallRules" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShaping) contextValidateL7FirewallRules(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.L7FirewallRules); i++ {

		if o.L7FirewallRules[i] != nil {
			if err := o.L7FirewallRules[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createNetworkGroupPolicy" + "." + "firewallAndTrafficShaping" + "." + "l7FirewallRules" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createNetworkGroupPolicy" + "." + "firewallAndTrafficShaping" + "." + "l7FirewallRules" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShaping) contextValidateTrafficShapingRules(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.TrafficShapingRules); i++ {

		if o.TrafficShapingRules[i] != nil {
			if err := o.TrafficShapingRules[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createNetworkGroupPolicy" + "." + "firewallAndTrafficShaping" + "." + "trafficShapingRules" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createNetworkGroupPolicy" + "." + "firewallAndTrafficShaping" + "." + "trafficShapingRules" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShaping) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShaping) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShaping
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL3FirewallRulesItems0 create network group policy params body firewall and traffic shaping l3 firewall rules items0
swagger:model CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL3FirewallRulesItems0
*/
type CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL3FirewallRulesItems0 struct {

	// Description of the rule (optional)
	Comment string `json:"comment,omitempty"`

	// Destination IP address (in IP or CIDR notation), a fully-qualified domain name (FQDN, if your network supports it) or 'any'.
	// Required: true
	DestCidr *string `json:"destCidr"`

	// Destination port (integer in the range 1-65535), a port range (e.g. 8080-9090), or 'any'
	DestPort string `json:"destPort,omitempty"`

	// 'allow' or 'deny' traffic specified by this rule
	// Required: true
	Policy *string `json:"policy"`

	// The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
	// Required: true
	Protocol *string `json:"protocol"`
}

// Validate validates this create network group policy params body firewall and traffic shaping l3 firewall rules items0
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL3FirewallRulesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDestCidr(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProtocol(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL3FirewallRulesItems0) validateDestCidr(formats strfmt.Registry) error {

	if err := validate.Required("destCidr", "body", o.DestCidr); err != nil {
		return err
	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL3FirewallRulesItems0) validatePolicy(formats strfmt.Registry) error {

	if err := validate.Required("policy", "body", o.Policy); err != nil {
		return err
	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL3FirewallRulesItems0) validateProtocol(formats strfmt.Registry) error {

	if err := validate.Required("protocol", "body", o.Protocol); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create network group policy params body firewall and traffic shaping l3 firewall rules items0 based on context it is used
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL3FirewallRulesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL3FirewallRulesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL3FirewallRulesItems0) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL3FirewallRulesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0 create network group policy params body firewall and traffic shaping l7 firewall rules items0
swagger:model CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0
*/
type CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0 struct {

	// The policy applied to matching traffic. Must be 'deny'.
	// Enum: [deny]
	Policy string `json:"policy,omitempty"`

	// Type of the L7 Rule. Must be 'application', 'applicationCategory', 'host', 'port' or 'ipRange'
	// Enum: [application applicationCategory host port ipRange]
	Type string `json:"type,omitempty"`

	// The 'value' of what you want to block. If 'type' is 'host', 'port' or 'ipRange', 'value' must be a string matching either a hostname (e.g. somewhere.com), a port (e.g. 8080), or an IP range (e.g. 192.1.0.0/16). If 'type' is 'application' or 'applicationCategory', then 'value' must be an object with an ID for the application.
	Value string `json:"value,omitempty"`
}

// Validate validates this create network group policy params body firewall and traffic shaping l7 firewall rules items0
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var createNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0TypePolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["deny"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0TypePolicyPropEnum = append(createNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0TypePolicyPropEnum, v)
	}
}

const (

	// CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0PolicyDeny captures enum value "deny"
	CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0PolicyDeny string = "deny"
)

// prop value enum
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0) validatePolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0TypePolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(o.Policy) { // not required
		return nil
	}

	// value enum
	if err := o.validatePolicyEnum("policy", "body", o.Policy); err != nil {
		return err
	}

	return nil
}

var createNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["application","applicationCategory","host","port","ipRange"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0TypeTypePropEnum = append(createNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0TypeTypePropEnum, v)
	}
}

const (

	// CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0TypeApplication captures enum value "application"
	CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0TypeApplication string = "application"

	// CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0TypeApplicationCategory captures enum value "applicationCategory"
	CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0TypeApplicationCategory string = "applicationCategory"

	// CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0TypeHost captures enum value "host"
	CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0TypeHost string = "host"

	// CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0TypePort captures enum value "port"
	CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0TypePort string = "port"

	// CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0TypeIPRange captures enum value "ipRange"
	CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0TypeIPRange string = "ipRange"
)

// prop value enum
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0TypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0) validateType(formats strfmt.Registry) error {
	if swag.IsZero(o.Type) { // not required
		return nil
	}

	// value enum
	if err := o.validateTypeEnum("type", "body", o.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create network group policy params body firewall and traffic shaping l7 firewall rules items0 based on context it is used
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingL7FirewallRulesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0 create network group policy params body firewall and traffic shaping traffic shaping rules items0
swagger:model CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0
*/
type CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0 struct {

	//     A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
	//
	// Required: true
	Definitions []*CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0 `json:"definitions"`

	//     The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
	//     For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
	//
	DscpTagValue int64 `json:"dscpTagValue,omitempty"`

	//     The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
	//     null means 'Do not set PCP tag'.
	//
	PcpTagValue int64 `json:"pcpTagValue,omitempty"`

	// per client bandwidth limits
	PerClientBandwidthLimits *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0PerClientBandwidthLimits `json:"perClientBandwidthLimits,omitempty"`

	//     A string, indicating the priority level for packets bound to your rule.
	//     Can be 'low', 'normal' or 'high'.
	//
	Priority string `json:"priority,omitempty"`
}

// Validate validates this create network group policy params body firewall and traffic shaping traffic shaping rules items0
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDefinitions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePerClientBandwidthLimits(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0) validateDefinitions(formats strfmt.Registry) error {

	if err := validate.Required("definitions", "body", o.Definitions); err != nil {
		return err
	}

	for i := 0; i < len(o.Definitions); i++ {
		if swag.IsZero(o.Definitions[i]) { // not required
			continue
		}

		if o.Definitions[i] != nil {
			if err := o.Definitions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("definitions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("definitions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0) validatePerClientBandwidthLimits(formats strfmt.Registry) error {
	if swag.IsZero(o.PerClientBandwidthLimits) { // not required
		return nil
	}

	if o.PerClientBandwidthLimits != nil {
		if err := o.PerClientBandwidthLimits.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("perClientBandwidthLimits")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("perClientBandwidthLimits")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create network group policy params body firewall and traffic shaping traffic shaping rules items0 based on the context it is used
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDefinitions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePerClientBandwidthLimits(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0) contextValidateDefinitions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Definitions); i++ {

		if o.Definitions[i] != nil {
			if err := o.Definitions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("definitions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("definitions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0) contextValidatePerClientBandwidthLimits(ctx context.Context, formats strfmt.Registry) error {

	if o.PerClientBandwidthLimits != nil {
		if err := o.PerClientBandwidthLimits.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("perClientBandwidthLimits")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("perClientBandwidthLimits")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0 create network group policy params body firewall and traffic shaping traffic shaping rules items0 definitions items0
swagger:model CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0
*/
type CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0 struct {

	// The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
	// Required: true
	// Enum: [application applicationCategory host port ipRange localNet]
	Type *string `json:"type"`

	//     If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
	//     a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
	//     "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
	//     custom ports.
	//      If "type" is 'application' or 'applicationCategory', then "value" must be an object
	//     with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
	//     application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
	//     endpoint).
	//
	// Required: true
	Value *string `json:"value"`
}

// Validate validates this create network group policy params body firewall and traffic shaping traffic shaping rules items0 definitions items0
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var createNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["application","applicationCategory","host","port","ipRange","localNet"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0TypeTypePropEnum = append(createNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0TypeTypePropEnum, v)
	}
}

const (

	// CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0TypeApplication captures enum value "application"
	CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0TypeApplication string = "application"

	// CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0TypeApplicationCategory captures enum value "applicationCategory"
	CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0TypeApplicationCategory string = "applicationCategory"

	// CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0TypeHost captures enum value "host"
	CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0TypeHost string = "host"

	// CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0TypePort captures enum value "port"
	CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0TypePort string = "port"

	// CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0TypeIPRange captures enum value "ipRange"
	CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0TypeIPRange string = "ipRange"

	// CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0TypeLocalNet captures enum value "localNet"
	CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0TypeLocalNet string = "localNet"
)

// prop value enum
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0TypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", o.Type); err != nil {
		return err
	}

	// value enum
	if err := o.validateTypeEnum("type", "body", *o.Type); err != nil {
		return err
	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0) validateValue(formats strfmt.Registry) error {

	if err := validate.Required("value", "body", o.Value); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create network group policy params body firewall and traffic shaping traffic shaping rules items0 definitions items0 based on context it is used
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0DefinitionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0PerClientBandwidthLimits     An object describing the bandwidth settings for your rule.
//
swagger:model CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0PerClientBandwidthLimits
*/
type CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0PerClientBandwidthLimits struct {

	// bandwidth limits
	BandwidthLimits *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0PerClientBandwidthLimitsBandwidthLimits `json:"bandwidthLimits,omitempty"`

	// How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
	Settings string `json:"settings,omitempty"`
}

// Validate validates this create network group policy params body firewall and traffic shaping traffic shaping rules items0 per client bandwidth limits
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0PerClientBandwidthLimits) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBandwidthLimits(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0PerClientBandwidthLimits) validateBandwidthLimits(formats strfmt.Registry) error {
	if swag.IsZero(o.BandwidthLimits) { // not required
		return nil
	}

	if o.BandwidthLimits != nil {
		if err := o.BandwidthLimits.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("perClientBandwidthLimits" + "." + "bandwidthLimits")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("perClientBandwidthLimits" + "." + "bandwidthLimits")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create network group policy params body firewall and traffic shaping traffic shaping rules items0 per client bandwidth limits based on the context it is used
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0PerClientBandwidthLimits) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBandwidthLimits(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0PerClientBandwidthLimits) contextValidateBandwidthLimits(ctx context.Context, formats strfmt.Registry) error {

	if o.BandwidthLimits != nil {
		if err := o.BandwidthLimits.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("perClientBandwidthLimits" + "." + "bandwidthLimits")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("perClientBandwidthLimits" + "." + "bandwidthLimits")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0PerClientBandwidthLimits) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0PerClientBandwidthLimits) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0PerClientBandwidthLimits
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0PerClientBandwidthLimitsBandwidthLimits The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
swagger:model CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0PerClientBandwidthLimitsBandwidthLimits
*/
type CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0PerClientBandwidthLimitsBandwidthLimits struct {

	// The maximum download limit (integer, in Kbps).
	LimitDown int64 `json:"limitDown,omitempty"`

	// The maximum upload limit (integer, in Kbps).
	LimitUp int64 `json:"limitUp,omitempty"`
}

// Validate validates this create network group policy params body firewall and traffic shaping traffic shaping rules items0 per client bandwidth limits bandwidth limits
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0PerClientBandwidthLimitsBandwidthLimits) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create network group policy params body firewall and traffic shaping traffic shaping rules items0 per client bandwidth limits bandwidth limits based on context it is used
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0PerClientBandwidthLimitsBandwidthLimits) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0PerClientBandwidthLimitsBandwidthLimits) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0PerClientBandwidthLimitsBandwidthLimits) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodyFirewallAndTrafficShapingTrafficShapingRulesItems0PerClientBandwidthLimitsBandwidthLimits
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodyScheduling     The schedule for the group policy. Schedules are applied to days of the week.
//
swagger:model CreateNetworkGroupPolicyParamsBodyScheduling
*/
type CreateNetworkGroupPolicyParamsBodyScheduling struct {

	// Whether scheduling is enabled (true) or disabled (false). Defaults to false. If true, the schedule objects for each day of the week (monday - sunday) are parsed.
	Enabled bool `json:"enabled,omitempty"`

	// friday
	Friday *CreateNetworkGroupPolicyParamsBodySchedulingFriday `json:"friday,omitempty"`

	// monday
	Monday *CreateNetworkGroupPolicyParamsBodySchedulingMonday `json:"monday,omitempty"`

	// saturday
	Saturday *CreateNetworkGroupPolicyParamsBodySchedulingSaturday `json:"saturday,omitempty"`

	// sunday
	Sunday *CreateNetworkGroupPolicyParamsBodySchedulingSunday `json:"sunday,omitempty"`

	// thursday
	Thursday *CreateNetworkGroupPolicyParamsBodySchedulingThursday `json:"thursday,omitempty"`

	// tuesday
	Tuesday *CreateNetworkGroupPolicyParamsBodySchedulingTuesday `json:"tuesday,omitempty"`

	// wednesday
	Wednesday *CreateNetworkGroupPolicyParamsBodySchedulingWednesday `json:"wednesday,omitempty"`
}

// Validate validates this create network group policy params body scheduling
func (o *CreateNetworkGroupPolicyParamsBodyScheduling) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateFriday(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMonday(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSaturday(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSunday(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateThursday(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTuesday(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWednesday(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyScheduling) validateFriday(formats strfmt.Registry) error {
	if swag.IsZero(o.Friday) { // not required
		return nil
	}

	if o.Friday != nil {
		if err := o.Friday.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "friday")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "friday")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyScheduling) validateMonday(formats strfmt.Registry) error {
	if swag.IsZero(o.Monday) { // not required
		return nil
	}

	if o.Monday != nil {
		if err := o.Monday.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "monday")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "monday")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyScheduling) validateSaturday(formats strfmt.Registry) error {
	if swag.IsZero(o.Saturday) { // not required
		return nil
	}

	if o.Saturday != nil {
		if err := o.Saturday.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "saturday")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "saturday")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyScheduling) validateSunday(formats strfmt.Registry) error {
	if swag.IsZero(o.Sunday) { // not required
		return nil
	}

	if o.Sunday != nil {
		if err := o.Sunday.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "sunday")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "sunday")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyScheduling) validateThursday(formats strfmt.Registry) error {
	if swag.IsZero(o.Thursday) { // not required
		return nil
	}

	if o.Thursday != nil {
		if err := o.Thursday.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "thursday")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "thursday")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyScheduling) validateTuesday(formats strfmt.Registry) error {
	if swag.IsZero(o.Tuesday) { // not required
		return nil
	}

	if o.Tuesday != nil {
		if err := o.Tuesday.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "tuesday")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "tuesday")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyScheduling) validateWednesday(formats strfmt.Registry) error {
	if swag.IsZero(o.Wednesday) { // not required
		return nil
	}

	if o.Wednesday != nil {
		if err := o.Wednesday.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "wednesday")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "wednesday")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create network group policy params body scheduling based on the context it is used
func (o *CreateNetworkGroupPolicyParamsBodyScheduling) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateFriday(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMonday(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSaturday(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSunday(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateThursday(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTuesday(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateWednesday(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyScheduling) contextValidateFriday(ctx context.Context, formats strfmt.Registry) error {

	if o.Friday != nil {
		if err := o.Friday.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "friday")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "friday")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyScheduling) contextValidateMonday(ctx context.Context, formats strfmt.Registry) error {

	if o.Monday != nil {
		if err := o.Monday.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "monday")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "monday")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyScheduling) contextValidateSaturday(ctx context.Context, formats strfmt.Registry) error {

	if o.Saturday != nil {
		if err := o.Saturday.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "saturday")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "saturday")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyScheduling) contextValidateSunday(ctx context.Context, formats strfmt.Registry) error {

	if o.Sunday != nil {
		if err := o.Sunday.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "sunday")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "sunday")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyScheduling) contextValidateThursday(ctx context.Context, formats strfmt.Registry) error {

	if o.Thursday != nil {
		if err := o.Thursday.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "thursday")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "thursday")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyScheduling) contextValidateTuesday(ctx context.Context, formats strfmt.Registry) error {

	if o.Tuesday != nil {
		if err := o.Tuesday.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "tuesday")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "tuesday")
			}
			return err
		}
	}

	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyScheduling) contextValidateWednesday(ctx context.Context, formats strfmt.Registry) error {

	if o.Wednesday != nil {
		if err := o.Wednesday.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "wednesday")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createNetworkGroupPolicy" + "." + "scheduling" + "." + "wednesday")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyScheduling) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyScheduling) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodyScheduling
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodySchedulingFriday The schedule object for Friday.
swagger:model CreateNetworkGroupPolicyParamsBodySchedulingFriday
*/
type CreateNetworkGroupPolicyParamsBodySchedulingFriday struct {

	// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
	Active bool `json:"active,omitempty"`

	// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
	From string `json:"from,omitempty"`

	// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
	To string `json:"to,omitempty"`
}

// Validate validates this create network group policy params body scheduling friday
func (o *CreateNetworkGroupPolicyParamsBodySchedulingFriday) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create network group policy params body scheduling friday based on context it is used
func (o *CreateNetworkGroupPolicyParamsBodySchedulingFriday) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodySchedulingFriday) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodySchedulingFriday) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodySchedulingFriday
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodySchedulingMonday The schedule object for Monday.
swagger:model CreateNetworkGroupPolicyParamsBodySchedulingMonday
*/
type CreateNetworkGroupPolicyParamsBodySchedulingMonday struct {

	// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
	Active bool `json:"active,omitempty"`

	// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
	From string `json:"from,omitempty"`

	// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
	To string `json:"to,omitempty"`
}

// Validate validates this create network group policy params body scheduling monday
func (o *CreateNetworkGroupPolicyParamsBodySchedulingMonday) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create network group policy params body scheduling monday based on context it is used
func (o *CreateNetworkGroupPolicyParamsBodySchedulingMonday) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodySchedulingMonday) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodySchedulingMonday) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodySchedulingMonday
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodySchedulingSaturday The schedule object for Saturday.
swagger:model CreateNetworkGroupPolicyParamsBodySchedulingSaturday
*/
type CreateNetworkGroupPolicyParamsBodySchedulingSaturday struct {

	// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
	Active bool `json:"active,omitempty"`

	// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
	From string `json:"from,omitempty"`

	// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
	To string `json:"to,omitempty"`
}

// Validate validates this create network group policy params body scheduling saturday
func (o *CreateNetworkGroupPolicyParamsBodySchedulingSaturday) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create network group policy params body scheduling saturday based on context it is used
func (o *CreateNetworkGroupPolicyParamsBodySchedulingSaturday) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodySchedulingSaturday) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodySchedulingSaturday) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodySchedulingSaturday
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodySchedulingSunday The schedule object for Sunday.
swagger:model CreateNetworkGroupPolicyParamsBodySchedulingSunday
*/
type CreateNetworkGroupPolicyParamsBodySchedulingSunday struct {

	// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
	Active bool `json:"active,omitempty"`

	// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
	From string `json:"from,omitempty"`

	// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
	To string `json:"to,omitempty"`
}

// Validate validates this create network group policy params body scheduling sunday
func (o *CreateNetworkGroupPolicyParamsBodySchedulingSunday) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create network group policy params body scheduling sunday based on context it is used
func (o *CreateNetworkGroupPolicyParamsBodySchedulingSunday) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodySchedulingSunday) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodySchedulingSunday) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodySchedulingSunday
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodySchedulingThursday The schedule object for Thursday.
swagger:model CreateNetworkGroupPolicyParamsBodySchedulingThursday
*/
type CreateNetworkGroupPolicyParamsBodySchedulingThursday struct {

	// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
	Active bool `json:"active,omitempty"`

	// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
	From string `json:"from,omitempty"`

	// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
	To string `json:"to,omitempty"`
}

// Validate validates this create network group policy params body scheduling thursday
func (o *CreateNetworkGroupPolicyParamsBodySchedulingThursday) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create network group policy params body scheduling thursday based on context it is used
func (o *CreateNetworkGroupPolicyParamsBodySchedulingThursday) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodySchedulingThursday) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodySchedulingThursday) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodySchedulingThursday
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodySchedulingTuesday The schedule object for Tuesday.
swagger:model CreateNetworkGroupPolicyParamsBodySchedulingTuesday
*/
type CreateNetworkGroupPolicyParamsBodySchedulingTuesday struct {

	// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
	Active bool `json:"active,omitempty"`

	// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
	From string `json:"from,omitempty"`

	// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
	To string `json:"to,omitempty"`
}

// Validate validates this create network group policy params body scheduling tuesday
func (o *CreateNetworkGroupPolicyParamsBodySchedulingTuesday) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create network group policy params body scheduling tuesday based on context it is used
func (o *CreateNetworkGroupPolicyParamsBodySchedulingTuesday) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodySchedulingTuesday) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodySchedulingTuesday) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodySchedulingTuesday
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodySchedulingWednesday The schedule object for Wednesday.
swagger:model CreateNetworkGroupPolicyParamsBodySchedulingWednesday
*/
type CreateNetworkGroupPolicyParamsBodySchedulingWednesday struct {

	// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
	Active bool `json:"active,omitempty"`

	// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
	From string `json:"from,omitempty"`

	// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
	To string `json:"to,omitempty"`
}

// Validate validates this create network group policy params body scheduling wednesday
func (o *CreateNetworkGroupPolicyParamsBodySchedulingWednesday) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create network group policy params body scheduling wednesday based on context it is used
func (o *CreateNetworkGroupPolicyParamsBodySchedulingWednesday) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodySchedulingWednesday) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodySchedulingWednesday) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodySchedulingWednesday
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateNetworkGroupPolicyParamsBodyVlanTagging The VLAN tagging settings for your group policy. Only available if your network has a wireless configuration.
swagger:model CreateNetworkGroupPolicyParamsBodyVlanTagging
*/
type CreateNetworkGroupPolicyParamsBodyVlanTagging struct {

	// How VLAN tagging is applied. Can be 'network default', 'ignore' or 'custom'.
	// Enum: [network default ignore custom]
	Settings string `json:"settings,omitempty"`

	// The ID of the vlan you want to tag. This only applies if 'settings' is set to 'custom'.
	VlanID string `json:"vlanId,omitempty"`
}

// Validate validates this create network group policy params body vlan tagging
func (o *CreateNetworkGroupPolicyParamsBodyVlanTagging) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSettings(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var createNetworkGroupPolicyParamsBodyVlanTaggingTypeSettingsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["network default","ignore","custom"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createNetworkGroupPolicyParamsBodyVlanTaggingTypeSettingsPropEnum = append(createNetworkGroupPolicyParamsBodyVlanTaggingTypeSettingsPropEnum, v)
	}
}

const (

	// CreateNetworkGroupPolicyParamsBodyVlanTaggingSettingsNetworkDefault captures enum value "network default"
	CreateNetworkGroupPolicyParamsBodyVlanTaggingSettingsNetworkDefault string = "network default"

	// CreateNetworkGroupPolicyParamsBodyVlanTaggingSettingsIgnore captures enum value "ignore"
	CreateNetworkGroupPolicyParamsBodyVlanTaggingSettingsIgnore string = "ignore"

	// CreateNetworkGroupPolicyParamsBodyVlanTaggingSettingsCustom captures enum value "custom"
	CreateNetworkGroupPolicyParamsBodyVlanTaggingSettingsCustom string = "custom"
)

// prop value enum
func (o *CreateNetworkGroupPolicyParamsBodyVlanTagging) validateSettingsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createNetworkGroupPolicyParamsBodyVlanTaggingTypeSettingsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *CreateNetworkGroupPolicyParamsBodyVlanTagging) validateSettings(formats strfmt.Registry) error {
	if swag.IsZero(o.Settings) { // not required
		return nil
	}

	// value enum
	if err := o.validateSettingsEnum("createNetworkGroupPolicy"+"."+"vlanTagging"+"."+"settings", "body", o.Settings); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create network group policy params body vlan tagging based on context it is used
func (o *CreateNetworkGroupPolicyParamsBodyVlanTagging) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyVlanTagging) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateNetworkGroupPolicyParamsBodyVlanTagging) UnmarshalBinary(b []byte) error {
	var res CreateNetworkGroupPolicyParamsBodyVlanTagging
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
